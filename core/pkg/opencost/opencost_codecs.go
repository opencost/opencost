////////////////////////////////////////////////////////////////////////////////
//
//                             DO NOT MODIFY
//
//                          ┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻
//
//
//            This source file was automatically generated by bingen.
//
////////////////////////////////////////////////////////////////////////////////

package opencost

import (
	"fmt"
	"reflect"
	"strings"
	"sync"
	"time"

	util "github.com/opencost/opencost/core/pkg/util"
)

const (
	// GeneratorPackageName is the package the generator is targetting
	GeneratorPackageName string = "opencost"
)

// BinaryTags represent the formatting tag used for specific optimization features
const (
	// BinaryTagStringTable is written and/or read prior to the existence of a string
	// table (where each index is encoded as a string entry in the resource
	BinaryTagStringTable string = "BGST"
)

const (
	// DefaultCodecVersion is used for any resources listed in the Default version set
	DefaultCodecVersion uint8 = 17

	// AssetsCodecVersion is used for any resources listed in the Assets version set
	AssetsCodecVersion uint8 = 21

	// AllocationCodecVersion is used for any resources listed in the Allocation version set
	AllocationCodecVersion uint8 = 22

	// CloudCostCodecVersion is used for any resources listed in the CloudCost version set
	CloudCostCodecVersion uint8 = 3
)

//--------------------------------------------------------------------------
//  Type Map
//--------------------------------------------------------------------------

// Generated type map for resolving interface implementations to
// to concrete types
var typeMap map[string]reflect.Type = map[string]reflect.Type{
	"Allocation":            reflect.TypeOf((*Allocation)(nil)).Elem(),
	"AllocationProperties":  reflect.TypeOf((*AllocationProperties)(nil)).Elem(),
	"AllocationSet":         reflect.TypeOf((*AllocationSet)(nil)).Elem(),
	"AllocationSetRange":    reflect.TypeOf((*AllocationSetRange)(nil)).Elem(),
	"Any":                   reflect.TypeOf((*Any)(nil)).Elem(),
	"AssetProperties":       reflect.TypeOf((*AssetProperties)(nil)).Elem(),
	"AssetSet":              reflect.TypeOf((*AssetSet)(nil)).Elem(),
	"AssetSetRange":         reflect.TypeOf((*AssetSetRange)(nil)).Elem(),
	"Breakdown":             reflect.TypeOf((*Breakdown)(nil)).Elem(),
	"Cloud":                 reflect.TypeOf((*Cloud)(nil)).Elem(),
	"CloudCost":             reflect.TypeOf((*CloudCost)(nil)).Elem(),
	"CloudCostProperties":   reflect.TypeOf((*CloudCostProperties)(nil)).Elem(),
	"CloudCostSet":          reflect.TypeOf((*CloudCostSet)(nil)).Elem(),
	"CloudCostSetRange":     reflect.TypeOf((*CloudCostSetRange)(nil)).Elem(),
	"ClusterManagement":     reflect.TypeOf((*ClusterManagement)(nil)).Elem(),
	"CostMetric":            reflect.TypeOf((*CostMetric)(nil)).Elem(),
	"Coverage":              reflect.TypeOf((*Coverage)(nil)).Elem(),
	"CoverageSet":           reflect.TypeOf((*CoverageSet)(nil)).Elem(),
	"Disk":                  reflect.TypeOf((*Disk)(nil)).Elem(),
	"LbAllocation":          reflect.TypeOf((*LbAllocation)(nil)).Elem(),
	"LoadBalancer":          reflect.TypeOf((*LoadBalancer)(nil)).Elem(),
	"Network":               reflect.TypeOf((*Network)(nil)).Elem(),
	"Node":                  reflect.TypeOf((*Node)(nil)).Elem(),
	"NodeOverhead":          reflect.TypeOf((*NodeOverhead)(nil)).Elem(),
	"PVAllocation":          reflect.TypeOf((*PVAllocation)(nil)).Elem(),
	"PVKey":                 reflect.TypeOf((*PVKey)(nil)).Elem(),
	"RawAllocationOnlyData": reflect.TypeOf((*RawAllocationOnlyData)(nil)).Elem(),
	"SharedAsset":           reflect.TypeOf((*SharedAsset)(nil)).Elem(),
	"Window":                reflect.TypeOf((*Window)(nil)).Elem(),
}

//--------------------------------------------------------------------------
//  Type Helpers
//--------------------------------------------------------------------------

// isBinaryTag returns true when the first bytes in the provided binary matches the tag
func isBinaryTag(data []byte, tag string) bool {
	return string(data[:len(tag)]) == tag
}

// appendBytes combines a and b into a new byte array
func appendBytes(a []byte, b []byte) []byte {
	al := len(a)
	bl := len(b)
	tl := al + bl

	// allocate a new byte array for the combined
	// use native copy for speedy byte copying
	result := make([]byte, tl, tl)
	copy(result, a)
	copy(result[al:], b)

	return result
}

// typeToString determines the basic properties of the type, the qualifier, package path, and
// type name, and returns the qualified type
func typeToString(f interface{}) string {
	qual := ""
	t := reflect.TypeOf(f)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
		qual = "*"
	}

	return fmt.Sprintf("%s%s.%s", qual, t.PkgPath(), t.Name())
}

// resolveType uses the name of a type and returns the package, base type name, and whether
// or not it's a pointer.
func resolveType(t string) (pkg string, name string, isPtr bool) {
	isPtr = t[:1] == "*"
	if isPtr {
		t = t[1:]
	}

	slashIndex := strings.LastIndex(t, "/")
	if slashIndex >= 0 {
		t = t[slashIndex+1:]
	}
	parts := strings.Split(t, ".")
	if parts[0] == GeneratorPackageName {
		parts[0] = ""
	}

	pkg = parts[0]
	name = parts[1]
	return
}

//--------------------------------------------------------------------------
//  StringTable
//--------------------------------------------------------------------------

// StringTable maps strings to specific indices for encoding
type StringTable struct {
	l       *sync.Mutex
	indices map[string]int
	next    int
}

// NewStringTable Creates a new StringTable instance with provided contents
func NewStringTable(contents ...string) *StringTable {
	st := &StringTable{
		l:       new(sync.Mutex),
		indices: make(map[string]int),
		next:    len(contents),
	}

	for i, entry := range contents {
		st.indices[entry] = i
	}

	return st
}

// AddOrGet atomically retrieves a string entry's index if it exist. Otherwise, it will
// add the entry and return the index.
func (st *StringTable) AddOrGet(s string) int {
	st.l.Lock()
	defer st.l.Unlock()

	if ind, ok := st.indices[s]; ok {
		return ind
	}

	current := st.next
	st.next++

	st.indices[s] = current
	return current
}

// ToSlice Converts the contents to a string array for encoding.
func (st *StringTable) ToSlice() []string {
	st.l.Lock()
	defer st.l.Unlock()

	if st.next == 0 {
		return []string{}
	}

	sl := make([]string, st.next, st.next)
	for s, i := range st.indices {
		sl[i] = s
	}
	return sl
}

// ToBytes Converts the contents to a binary encoded representation
func (st *StringTable) ToBytes() []byte {
	buff := util.NewBuffer()
	buff.WriteBytes([]byte(BinaryTagStringTable)) // bingen table header

	strs := st.ToSlice()

	buff.WriteInt(len(strs)) // table length
	for _, s := range strs {
		buff.WriteString(s)
	}

	return buff.Bytes()
}

//--------------------------------------------------------------------------
//  Codec Context
//--------------------------------------------------------------------------

// EncodingContext is a context object passed to the encoders to ensure reuse of buffer
// and table data
type EncodingContext struct {
	Buffer *util.Buffer
	Table  *StringTable
}

// IsStringTable returns true if the table is available
func (ec *EncodingContext) IsStringTable() bool {
	return ec.Table != nil
}

// DecodingContext is a context object passed to the decoders to ensure parent objects
// reuse as much data as possible
type DecodingContext struct {
	Buffer *util.Buffer
	Table  []string
}

// IsStringTable returns true if the table is available
func (dc *DecodingContext) IsStringTable() bool {
	return len(dc.Table) > 0
}

//--------------------------------------------------------------------------
//  Binary Codec
//--------------------------------------------------------------------------

// BinEncoder is an encoding interface which defines a context based marshal contract.
type BinEncoder interface {
	MarshalBinaryWithContext(*EncodingContext) error
}

// BinDecoder is a decoding interface which defines a context based unmarshal contract.
type BinDecoder interface {
	UnmarshalBinaryWithContext(*DecodingContext) error
}

//--------------------------------------------------------------------------
//  Allocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Allocation instance
// into a byte array
func (target *Allocation) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Allocation instance
// into a byte array leveraging a predefined context.
func (target *Allocation) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AllocationProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AllocationProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	// --- [begin][write][reference](time.Time) ---
	b, errC := target.Start.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errD := target.End.MarshalBinary()
	if errD != nil {
		return errD
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	buff.WriteFloat64(target.CPUCoreHours)               // write float64
	buff.WriteFloat64(target.CPUCoreRequestAverage)      // write float64
	buff.WriteFloat64(target.CPUCoreUsageAverage)        // write float64
	buff.WriteFloat64(target.CPUCost)                    // write float64
	buff.WriteFloat64(target.CPUCostAdjustment)          // write float64
	buff.WriteFloat64(target.GPUHours)                   // write float64
	buff.WriteFloat64(target.GPUCost)                    // write float64
	buff.WriteFloat64(target.GPUCostAdjustment)          // write float64
	buff.WriteFloat64(target.NetworkTransferBytes)       // write float64
	buff.WriteFloat64(target.NetworkReceiveBytes)        // write float64
	buff.WriteFloat64(target.NetworkCost)                // write float64
	buff.WriteFloat64(target.NetworkCrossZoneCost)       // write float64
	buff.WriteFloat64(target.NetworkCrossRegionCost)     // write float64
	buff.WriteFloat64(target.NetworkInternetCost)        // write float64
	buff.WriteFloat64(target.NetworkCostAdjustment)      // write float64
	buff.WriteFloat64(target.LoadBalancerCost)           // write float64
	buff.WriteFloat64(target.LoadBalancerCostAdjustment) // write float64
	// --- [begin][write][alias](PVAllocations) ---
	if map[PVKey]*PVAllocation(target.PVs) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[PVKey]*PVAllocation) ---
		buff.WriteInt(len(map[PVKey]*PVAllocation(target.PVs))) // map length
		for v, z := range map[PVKey]*PVAllocation(target.PVs) {
			// --- [begin][write][struct](PVKey) ---
			buff.WriteInt(0) // [compatibility, unused]
			errE := v.MarshalBinaryWithContext(ctx)
			if errE != nil {
				return errE
			}
			// --- [end][write][struct](PVKey) ---

			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](PVAllocation) ---
				buff.WriteInt(0) // [compatibility, unused]
				errF := z.MarshalBinaryWithContext(ctx)
				if errF != nil {
					return errF
				}
				// --- [end][write][struct](PVAllocation) ---

			}
		}
		// --- [end][write][map](map[PVKey]*PVAllocation) ---

	}
	// --- [end][write][alias](PVAllocations) ---

	buff.WriteFloat64(target.PVCostAdjustment)       // write float64
	buff.WriteFloat64(target.RAMByteHours)           // write float64
	buff.WriteFloat64(target.RAMBytesRequestAverage) // write float64
	buff.WriteFloat64(target.RAMBytesUsageAverage)   // write float64
	buff.WriteFloat64(target.RAMCost)                // write float64
	buff.WriteFloat64(target.RAMCostAdjustment)      // write float64
	buff.WriteFloat64(target.SharedCost)             // write float64
	buff.WriteFloat64(target.ExternalCost)           // write float64
	if target.RawAllocationOnly == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](RawAllocationOnlyData) ---
		buff.WriteInt(0) // [compatibility, unused]
		errG := target.RawAllocationOnly.MarshalBinaryWithContext(ctx)
		if errG != nil {
			return errG
		}
		// --- [end][write][struct](RawAllocationOnlyData) ---

	}
	// --- [begin][write][alias](LbAllocations) ---
	if map[string]*LbAllocation(target.LoadBalancers) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*LbAllocation) ---
		buff.WriteInt(len(map[string]*LbAllocation(target.LoadBalancers))) // map length
		for vv, zz := range map[string]*LbAllocation(target.LoadBalancers) {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(vv)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			if zz == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](LbAllocation) ---
				buff.WriteInt(0) // [compatibility, unused]
				errH := zz.MarshalBinaryWithContext(ctx)
				if errH != nil {
					return errH
				}
				// --- [end][write][struct](LbAllocation) ---

			}
		}
		// --- [end][write][map](map[string]*LbAllocation) ---

	}
	// --- [end][write][alias](LbAllocations) ---

	buff.WriteFloat64(target.GPURequestAverage) // write float64
	buff.WriteFloat64(target.GPUUsageAverage)   // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Allocation type
func (target *Allocation) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Allocation type
func (target *Allocation) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Allocation. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Name = a

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AllocationProperties) ---
		d := &AllocationProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := d.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = d
		// --- [end][read][struct](AllocationProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	e := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := e.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *e
	// --- [end][read][struct](Window) ---

	// --- [begin][read][reference](time.Time) ---
	f := &time.Time{}
	g := buff.ReadInt()    // byte array length
	h := buff.ReadBytes(g) // byte array
	errC := f.UnmarshalBinary(h)
	if errC != nil {
		return errC
	}
	target.Start = *f
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errD := k.UnmarshalBinary(m)
	if errD != nil {
		return errD
	}
	target.End = *k
	// --- [end][read][reference](time.Time) ---

	n := buff.ReadFloat64() // read float64
	target.CPUCoreHours = n

	o := buff.ReadFloat64() // read float64
	target.CPUCoreRequestAverage = o

	p := buff.ReadFloat64() // read float64
	target.CPUCoreUsageAverage = p

	q := buff.ReadFloat64() // read float64
	target.CPUCost = q

	r := buff.ReadFloat64() // read float64
	target.CPUCostAdjustment = r

	s := buff.ReadFloat64() // read float64
	target.GPUHours = s

	t := buff.ReadFloat64() // read float64
	target.GPUCost = t

	u := buff.ReadFloat64() // read float64
	target.GPUCostAdjustment = u

	w := buff.ReadFloat64() // read float64
	target.NetworkTransferBytes = w

	x := buff.ReadFloat64() // read float64
	target.NetworkReceiveBytes = x

	y := buff.ReadFloat64() // read float64
	target.NetworkCost = y

	// field version check
	if uint8(16) <= version {
		aa := buff.ReadFloat64() // read float64
		target.NetworkCrossZoneCost = aa

	} else {
		target.NetworkCrossZoneCost = float64(0) // default
	}

	// field version check
	if uint8(16) <= version {
		bb := buff.ReadFloat64() // read float64
		target.NetworkCrossRegionCost = bb

	} else {
		target.NetworkCrossRegionCost = float64(0) // default
	}

	// field version check
	if uint8(16) <= version {
		cc := buff.ReadFloat64() // read float64
		target.NetworkInternetCost = cc

	} else {
		target.NetworkInternetCost = float64(0) // default
	}

	dd := buff.ReadFloat64() // read float64
	target.NetworkCostAdjustment = dd

	ee := buff.ReadFloat64() // read float64
	target.LoadBalancerCost = ee

	ff := buff.ReadFloat64() // read float64
	target.LoadBalancerCostAdjustment = ff

	// --- [begin][read][alias](PVAllocations) ---
	var gg map[PVKey]*PVAllocation
	if buff.ReadUInt8() == uint8(0) {
		gg = nil
	} else {
		// --- [begin][read][map](map[PVKey]*PVAllocation) ---
		kk := buff.ReadInt() // map len
		hh := make(map[PVKey]*PVAllocation, kk)
		for i := 0; i < kk; i++ {
			// --- [begin][read][struct](PVKey) ---
			ll := &PVKey{}
			buff.ReadInt() // [compatibility, unused]
			errE := ll.UnmarshalBinaryWithContext(ctx)
			if errE != nil {
				return errE
			}
			v := *ll
			// --- [end][read][struct](PVKey) ---

			var z *PVAllocation
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](PVAllocation) ---
				mm := &PVAllocation{}
				buff.ReadInt() // [compatibility, unused]
				errF := mm.UnmarshalBinaryWithContext(ctx)
				if errF != nil {
					return errF
				}
				z = mm
				// --- [end][read][struct](PVAllocation) ---

			}
			hh[v] = z
		}
		gg = hh
		// --- [end][read][map](map[PVKey]*PVAllocation) ---

	}
	target.PVs = PVAllocations(gg)
	// --- [end][read][alias](PVAllocations) ---

	nn := buff.ReadFloat64() // read float64
	target.PVCostAdjustment = nn

	oo := buff.ReadFloat64() // read float64
	target.RAMByteHours = oo

	pp := buff.ReadFloat64() // read float64
	target.RAMBytesRequestAverage = pp

	qq := buff.ReadFloat64() // read float64
	target.RAMBytesUsageAverage = qq

	rr := buff.ReadFloat64() // read float64
	target.RAMCost = rr

	ss := buff.ReadFloat64() // read float64
	target.RAMCostAdjustment = ss

	tt := buff.ReadFloat64() // read float64
	target.SharedCost = tt

	uu := buff.ReadFloat64() // read float64
	target.ExternalCost = uu

	if buff.ReadUInt8() == uint8(0) {
		target.RawAllocationOnly = nil
	} else {
		// --- [begin][read][struct](RawAllocationOnlyData) ---
		ww := &RawAllocationOnlyData{}
		buff.ReadInt() // [compatibility, unused]
		errG := ww.UnmarshalBinaryWithContext(ctx)
		if errG != nil {
			return errG
		}
		target.RawAllocationOnly = ww
		// --- [end][read][struct](RawAllocationOnlyData) ---

	}
	// field version check
	if uint8(18) <= version {
		// --- [begin][read][alias](LbAllocations) ---
		var xx map[string]*LbAllocation
		if buff.ReadUInt8() == uint8(0) {
			xx = nil
		} else {
			// --- [begin][read][map](map[string]*LbAllocation) ---
			aaa := buff.ReadInt() // map len
			yy := make(map[string]*LbAllocation, aaa)
			for j := 0; j < aaa; j++ {
				var vv string
				var ccc string
				if ctx.IsStringTable() {
					ddd := buff.ReadInt() // read string index
					ccc = ctx.Table[ddd]
				} else {
					ccc = buff.ReadString() // read string
				}
				bbb := ccc
				vv = bbb

				var zz *LbAllocation
				if buff.ReadUInt8() == uint8(0) {
					zz = nil
				} else {
					// --- [begin][read][struct](LbAllocation) ---
					eee := &LbAllocation{}
					buff.ReadInt() // [compatibility, unused]
					errH := eee.UnmarshalBinaryWithContext(ctx)
					if errH != nil {
						return errH
					}
					zz = eee
					// --- [end][read][struct](LbAllocation) ---

				}
				yy[vv] = zz
			}
			xx = yy
			// --- [end][read][map](map[string]*LbAllocation) ---

		}
		target.LoadBalancers = LbAllocations(xx)
		// --- [end][read][alias](LbAllocations) ---

	} else {
	}

	// field version check
	if uint8(22) <= version {
		fff := buff.ReadFloat64() // read float64
		target.GPURequestAverage = fff

	} else {
		target.GPURequestAverage = float64(0) // default
	}

	// field version check
	if uint8(22) <= version {
		ggg := buff.ReadFloat64() // read float64
		target.GPUUsageAverage = ggg

	} else {
		target.GPUUsageAverage = float64(0) // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  AllocationProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationProperties instance
// into a byte array
func (target *AllocationProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationProperties instance
// into a byte array leveraging a predefined context.
func (target *AllocationProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Cluster)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Cluster) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Node)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Node) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Container)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Container) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.Controller)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.Controller) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.ControllerKind)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.ControllerKind) // write string
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.Namespace)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.Namespace) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.Pod)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.Pod) // write string
	}
	if target.Services == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Services)) // array length
		for i := 0; i < len(target.Services); i++ {
			if ctx.IsStringTable() {
				h := ctx.Table.AddOrGet(target.Services[i])
				buff.WriteInt(h) // write table index
			} else {
				buff.WriteString(target.Services[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if ctx.IsStringTable() {
		k := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(k) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	// --- [begin][write][alias](AllocationLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				l := ctx.Table.AddOrGet(v)
				buff.WriteInt(l) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				m := ctx.Table.AddOrGet(z)
				buff.WriteInt(m) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationLabels) ---

	// --- [begin][write][alias](AllocationAnnotations) ---
	if map[string]string(target.Annotations) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Annotations))) // map length
		for vv, zz := range map[string]string(target.Annotations) {
			if ctx.IsStringTable() {
				n := ctx.Table.AddOrGet(vv)
				buff.WriteInt(n) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			if ctx.IsStringTable() {
				o := ctx.Table.AddOrGet(zz)
				buff.WriteInt(o) // write table index
			} else {
				buff.WriteString(zz) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationAnnotations) ---

	// --- [begin][write][alias](AllocationLabels) ---
	if map[string]string(target.NamespaceLabels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.NamespaceLabels))) // map length
		for vvv, zzz := range map[string]string(target.NamespaceLabels) {
			if ctx.IsStringTable() {
				p := ctx.Table.AddOrGet(vvv)
				buff.WriteInt(p) // write table index
			} else {
				buff.WriteString(vvv) // write string
			}
			if ctx.IsStringTable() {
				q := ctx.Table.AddOrGet(zzz)
				buff.WriteInt(q) // write table index
			} else {
				buff.WriteString(zzz) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationLabels) ---

	// --- [begin][write][alias](AllocationAnnotations) ---
	if map[string]string(target.NamespaceAnnotations) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.NamespaceAnnotations))) // map length
		for vvvv, zzzz := range map[string]string(target.NamespaceAnnotations) {
			if ctx.IsStringTable() {
				r := ctx.Table.AddOrGet(vvvv)
				buff.WriteInt(r) // write table index
			} else {
				buff.WriteString(vvvv) // write string
			}
			if ctx.IsStringTable() {
				s := ctx.Table.AddOrGet(zzzz)
				buff.WriteInt(s) // write table index
			} else {
				buff.WriteString(zzzz) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationAnnotations) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationProperties type
func (target *AllocationProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationProperties type
func (target *AllocationProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationProperties. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Cluster = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Node = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.Container = g

	var m string
	if ctx.IsStringTable() {
		n := buff.ReadInt() // read string index
		m = ctx.Table[n]
	} else {
		m = buff.ReadString() // read string
	}
	l := m
	target.Controller = l

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.ControllerKind = o

	var s string
	if ctx.IsStringTable() {
		t := buff.ReadInt() // read string index
		s = ctx.Table[t]
	} else {
		s = buff.ReadString() // read string
	}
	r := s
	target.Namespace = r

	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.Pod = u

	if buff.ReadUInt8() == uint8(0) {
		target.Services = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		aa := buff.ReadInt() // array len
		y := make([]string, aa)
		for i := 0; i < aa; i++ {
			var bb string
			var dd string
			if ctx.IsStringTable() {
				ee := buff.ReadInt() // read string index
				dd = ctx.Table[ee]
			} else {
				dd = buff.ReadString() // read string
			}
			cc := dd
			bb = cc

			y[i] = bb
		}
		target.Services = y
		// --- [end][read][slice]([]string) ---

	}
	var gg string
	if ctx.IsStringTable() {
		hh := buff.ReadInt() // read string index
		gg = ctx.Table[hh]
	} else {
		gg = buff.ReadString() // read string
	}
	ff := gg
	target.ProviderID = ff

	// --- [begin][read][alias](AllocationLabels) ---
	var kk map[string]string
	if buff.ReadUInt8() == uint8(0) {
		kk = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		mm := buff.ReadInt() // map len
		ll := make(map[string]string, mm)
		for j := 0; j < mm; j++ {
			var v string
			var oo string
			if ctx.IsStringTable() {
				pp := buff.ReadInt() // read string index
				oo = ctx.Table[pp]
			} else {
				oo = buff.ReadString() // read string
			}
			nn := oo
			v = nn

			var z string
			var rr string
			if ctx.IsStringTable() {
				ss := buff.ReadInt() // read string index
				rr = ctx.Table[ss]
			} else {
				rr = buff.ReadString() // read string
			}
			qq := rr
			z = qq

			ll[v] = z
		}
		kk = ll
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AllocationLabels(kk)
	// --- [end][read][alias](AllocationLabels) ---

	// --- [begin][read][alias](AllocationAnnotations) ---
	var tt map[string]string
	if buff.ReadUInt8() == uint8(0) {
		tt = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		ww := buff.ReadInt() // map len
		uu := make(map[string]string, ww)
		for ii := 0; ii < ww; ii++ {
			var vv string
			var yy string
			if ctx.IsStringTable() {
				aaa := buff.ReadInt() // read string index
				yy = ctx.Table[aaa]
			} else {
				yy = buff.ReadString() // read string
			}
			xx := yy
			vv = xx

			var zz string
			var ccc string
			if ctx.IsStringTable() {
				ddd := buff.ReadInt() // read string index
				ccc = ctx.Table[ddd]
			} else {
				ccc = buff.ReadString() // read string
			}
			bbb := ccc
			zz = bbb

			uu[vv] = zz
		}
		tt = uu
		// --- [end][read][map](map[string]string) ---

	}
	target.Annotations = AllocationAnnotations(tt)
	// --- [end][read][alias](AllocationAnnotations) ---

	// field version check
	if uint8(17) <= version {
		// --- [begin][read][alias](AllocationLabels) ---
		var eee map[string]string
		if buff.ReadUInt8() == uint8(0) {
			eee = nil
		} else {
			// --- [begin][read][map](map[string]string) ---
			ggg := buff.ReadInt() // map len
			fff := make(map[string]string, ggg)
			for jj := 0; jj < ggg; jj++ {
				var vvv string
				var kkk string
				if ctx.IsStringTable() {
					lll := buff.ReadInt() // read string index
					kkk = ctx.Table[lll]
				} else {
					kkk = buff.ReadString() // read string
				}
				hhh := kkk
				vvv = hhh

				var zzz string
				var nnn string
				if ctx.IsStringTable() {
					ooo := buff.ReadInt() // read string index
					nnn = ctx.Table[ooo]
				} else {
					nnn = buff.ReadString() // read string
				}
				mmm := nnn
				zzz = mmm

				fff[vvv] = zzz
			}
			eee = fff
			// --- [end][read][map](map[string]string) ---

		}
		target.NamespaceLabels = AllocationLabels(eee)
		// --- [end][read][alias](AllocationLabels) ---

	} else {
	}

	// field version check
	if uint8(17) <= version {
		// --- [begin][read][alias](AllocationAnnotations) ---
		var ppp map[string]string
		if buff.ReadUInt8() == uint8(0) {
			ppp = nil
		} else {
			// --- [begin][read][map](map[string]string) ---
			rrr := buff.ReadInt() // map len
			qqq := make(map[string]string, rrr)
			for iii := 0; iii < rrr; iii++ {
				var vvvv string
				var ttt string
				if ctx.IsStringTable() {
					uuu := buff.ReadInt() // read string index
					ttt = ctx.Table[uuu]
				} else {
					ttt = buff.ReadString() // read string
				}
				sss := ttt
				vvvv = sss

				var zzzz string
				var xxx string
				if ctx.IsStringTable() {
					yyy := buff.ReadInt() // read string index
					xxx = ctx.Table[yyy]
				} else {
					xxx = buff.ReadString() // read string
				}
				www := xxx
				zzzz = www

				qqq[vvvv] = zzzz
			}
			ppp = qqq
			// --- [end][read][map](map[string]string) ---

		}
		target.NamespaceAnnotations = AllocationAnnotations(ppp)
		// --- [end][read][alias](AllocationAnnotations) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  AllocationSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSet instance
// into a byte array
func (target *AllocationSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationSet instance
// into a byte array leveraging a predefined context.
func (target *AllocationSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if target.Allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Allocation) ---
		buff.WriteInt(len(target.Allocations)) // map length
		for v, z := range target.Allocations {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Allocation) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := z.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](Allocation) ---

			}
		}
		// --- [end][write][map](map[string]*Allocation) ---

	}
	if target.ExternalKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.ExternalKeys)) // map length
		for vv, zz := range target.ExternalKeys {
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(vv)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			buff.WriteBool(zz) // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	if target.IdleKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.IdleKeys)) // map length
		for vvv, zzz := range target.IdleKeys {
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(vvv)
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(vvv) // write string
			}
			buff.WriteBool(zzz) // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.FromSource)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.FromSource) // write string
	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for i := 0; i < len(target.Warnings); i++ {
			if ctx.IsStringTable() {
				e := ctx.Table.AddOrGet(target.Warnings[i])
				buff.WriteInt(e) // write table index
			} else {
				buff.WriteString(target.Warnings[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for j := 0; j < len(target.Errors); j++ {
			if ctx.IsStringTable() {
				f := ctx.Table.AddOrGet(target.Errors[j])
				buff.WriteInt(f) // write table index
			} else {
				buff.WriteString(target.Errors[j]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSet type
func (target *AllocationSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationSet type
func (target *AllocationSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSet. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Allocations = nil
	} else {
		// --- [begin][read][map](map[string]*Allocation) ---
		b := buff.ReadInt() // map len
		a := make(map[string]*Allocation, b)
		for i := 0; i < b; i++ {
			var v string
			var d string
			if ctx.IsStringTable() {
				e := buff.ReadInt() // read string index
				d = ctx.Table[e]
			} else {
				d = buff.ReadString() // read string
			}
			c := d
			v = c

			var z *Allocation
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](Allocation) ---
				f := &Allocation{}
				buff.ReadInt() // [compatibility, unused]
				errA := f.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = f
				// --- [end][read][struct](Allocation) ---

			}
			a[v] = z
		}
		target.Allocations = a
		// --- [end][read][map](map[string]*Allocation) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.ExternalKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		h := buff.ReadInt() // map len
		g := make(map[string]bool, h)
		for j := 0; j < h; j++ {
			var vv string
			var l string
			if ctx.IsStringTable() {
				m := buff.ReadInt() // read string index
				l = ctx.Table[m]
			} else {
				l = buff.ReadString() // read string
			}
			k := l
			vv = k

			var zz bool
			n := buff.ReadBool() // read bool
			zz = n

			g[vv] = zz
		}
		target.ExternalKeys = g
		// --- [end][read][map](map[string]bool) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.IdleKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		p := buff.ReadInt() // map len
		o := make(map[string]bool, p)
		for ii := 0; ii < p; ii++ {
			var vvv string
			var r string
			if ctx.IsStringTable() {
				s := buff.ReadInt() // read string index
				r = ctx.Table[s]
			} else {
				r = buff.ReadString() // read string
			}
			q := r
			vvv = q

			var zzz bool
			t := buff.ReadBool() // read bool
			zzz = t

			o[vvv] = zzz
		}
		target.IdleKeys = o
		// --- [end][read][map](map[string]bool) ---

	}
	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.FromSource = u

	// --- [begin][read][struct](Window) ---
	y := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := y.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *y
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		bb := buff.ReadInt() // array len
		aa := make([]string, bb)
		for jj := 0; jj < bb; jj++ {
			var cc string
			var ee string
			if ctx.IsStringTable() {
				ff := buff.ReadInt() // read string index
				ee = ctx.Table[ff]
			} else {
				ee = buff.ReadString() // read string
			}
			dd := ee
			cc = dd

			aa[jj] = cc
		}
		target.Warnings = aa
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		hh := buff.ReadInt() // array len
		gg := make([]string, hh)
		for iii := 0; iii < hh; iii++ {
			var kk string
			var mm string
			if ctx.IsStringTable() {
				nn := buff.ReadInt() // read string index
				mm = ctx.Table[nn]
			} else {
				mm = buff.ReadString() // read string
			}
			ll := mm
			kk = ll

			gg[iii] = kk
		}
		target.Errors = gg
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AllocationSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSetRange instance
// into a byte array
func (target *AllocationSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationSetRange instance
// into a byte array leveraging a predefined context.
func (target *AllocationSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if target.Allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AllocationSet) ---
		buff.WriteInt(len(target.Allocations)) // array length
		for i := 0; i < len(target.Allocations); i++ {
			if target.Allocations[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AllocationSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.Allocations[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](AllocationSet) ---

			}
		}
		// --- [end][write][slice]([]*AllocationSet) ---

	}
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.FromStore)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.FromStore) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSetRange type
func (target *AllocationSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationSetRange type
func (target *AllocationSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSetRange. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Allocations = nil
	} else {
		// --- [begin][read][slice]([]*AllocationSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AllocationSet, b)
		for i := 0; i < b; i++ {
			var c *AllocationSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AllocationSet) ---
				d := &AllocationSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AllocationSet) ---

			}
			a[i] = c
		}
		target.Allocations = a
		// --- [end][read][slice]([]*AllocationSet) ---

	}
	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.FromStore = e

	return nil
}

//--------------------------------------------------------------------------
//  Any
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Any instance
// into a byte array
func (target *Any) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Any instance
// into a byte array leveraging a predefined context.
func (target *Any) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Any type
func (target *Any) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Any type
func (target *Any) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Any. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  AssetProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetProperties instance
// into a byte array
func (target *AssetProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetProperties instance
// into a byte array leveraging a predefined context.
func (target *AssetProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Category)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Category) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Provider)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Provider) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Account)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Account) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.Project)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.Project) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.Service)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.Service) // write string
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.Cluster)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.Cluster) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	if ctx.IsStringTable() {
		h := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(h) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetProperties type
func (target *AssetProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetProperties type
func (target *AssetProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetProperties. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Category = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Provider = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.Account = g

	var m string
	if ctx.IsStringTable() {
		n := buff.ReadInt() // read string index
		m = ctx.Table[n]
	} else {
		m = buff.ReadString() // read string
	}
	l := m
	target.Project = l

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.Service = o

	var s string
	if ctx.IsStringTable() {
		t := buff.ReadInt() // read string index
		s = ctx.Table[t]
	} else {
		s = buff.ReadString() // read string
	}
	r := s
	target.Cluster = r

	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.Name = u

	var aa string
	if ctx.IsStringTable() {
		bb := buff.ReadInt() // read string index
		aa = ctx.Table[bb]
	} else {
		aa = buff.ReadString() // read string
	}
	y := aa
	target.ProviderID = y

	return nil
}

//--------------------------------------------------------------------------
//  AssetSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSet instance
// into a byte array
func (target *AssetSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetSet instance
// into a byte array leveraging a predefined context.
func (target *AssetSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// execute pre-processing func
	preProcessAssetSet(target)
	if target.AggregationKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.AggregationKeys)) // array length
		for i := 0; i < len(target.AggregationKeys); i++ {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(target.AggregationKeys[i])
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(target.AggregationKeys[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]Asset) ---
		buff.WriteInt(len(target.Assets)) // map length
		for v, z := range target.Assets {
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(v)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][interface](Asset) ---
				c := reflect.ValueOf(z).Interface()
				d, okA := c.(BinEncoder)
				if !okA {
					return fmt.Errorf("Type: %s does not implement %s.BinEncoder", typeToString(z), GeneratorPackageName)
				}
				buff.WriteString(typeToString(z))
				buff.WriteInt(0) // [compatibility, unused]
				errA := d.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][interface](Asset) ---

			}
		}
		// --- [end][write][map](map[string]Asset) ---

	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.FromSource)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.FromSource) // write string
	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for j := 0; j < len(target.Warnings); j++ {
			if ctx.IsStringTable() {
				f := ctx.Table.AddOrGet(target.Warnings[j])
				buff.WriteInt(f) // write table index
			} else {
				buff.WriteString(target.Warnings[j]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for ii := 0; ii < len(target.Errors); ii++ {
			if ctx.IsStringTable() {
				g := ctx.Table.AddOrGet(target.Errors[ii])
				buff.WriteInt(g) // write table index
			} else {
				buff.WriteString(target.Errors[ii]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSet type
func (target *AssetSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetSet type
func (target *AssetSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSet. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.AggregationKeys = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		b := buff.ReadInt() // array len
		a := make([]string, b)
		for i := 0; i < b; i++ {
			var c string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			c = d

			a[i] = c
		}
		target.AggregationKeys = a
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Assets = nil
	} else {
		// --- [begin][read][map](map[string]Asset) ---
		h := buff.ReadInt() // map len
		g := make(map[string]Asset, h)
		for j := 0; j < h; j++ {
			var v string
			var l string
			if ctx.IsStringTable() {
				m := buff.ReadInt() // read string index
				l = ctx.Table[m]
			} else {
				l = buff.ReadString() // read string
			}
			k := l
			v = k

			var z Asset
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][interface](Asset) ---
				n := buff.ReadString()
				_, o, _ := resolveType(n)
				if _, ok := typeMap[o]; !ok {
					return fmt.Errorf("Unknown Type: %s", o)
				}
				p, okA := reflect.New(typeMap[o]).Interface().(BinDecoder)
				if !okA {
					return fmt.Errorf("Type: %s does not implement %s.BinDecoder.", o, GeneratorPackageName)
				}
				buff.ReadInt() // [compatibility, unused]
				errA := p.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = p.(Asset)
				// --- [end][read][interface](Asset) ---

			}
			g[v] = z
		}
		target.Assets = g
		// --- [end][read][map](map[string]Asset) ---

	}
	var r string
	if ctx.IsStringTable() {
		s := buff.ReadInt() // read string index
		r = ctx.Table[s]
	} else {
		r = buff.ReadString() // read string
	}
	q := r
	target.FromSource = q

	// --- [begin][read][struct](Window) ---
	t := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := t.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *t
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		w := buff.ReadInt() // array len
		u := make([]string, w)
		for ii := 0; ii < w; ii++ {
			var x string
			var aa string
			if ctx.IsStringTable() {
				bb := buff.ReadInt() // read string index
				aa = ctx.Table[bb]
			} else {
				aa = buff.ReadString() // read string
			}
			y := aa
			x = y

			u[ii] = x
		}
		target.Warnings = u
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		dd := buff.ReadInt() // array len
		cc := make([]string, dd)
		for jj := 0; jj < dd; jj++ {
			var ee string
			var gg string
			if ctx.IsStringTable() {
				hh := buff.ReadInt() // read string index
				gg = ctx.Table[hh]
			} else {
				gg = buff.ReadString() // read string
			}
			ff := gg
			ee = ff

			cc[jj] = ee
		}
		target.Errors = cc
		// --- [end][read][slice]([]string) ---

	}
	// execute post-processing func
	postProcessAssetSet(target)
	return nil
}

//--------------------------------------------------------------------------
//  AssetSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSetRange instance
// into a byte array
func (target *AssetSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetSetRange instance
// into a byte array leveraging a predefined context.
func (target *AssetSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AssetSet) ---
		buff.WriteInt(len(target.Assets)) // array length
		for i := 0; i < len(target.Assets); i++ {
			if target.Assets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AssetSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.Assets[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](AssetSet) ---

			}
		}
		// --- [end][write][slice]([]*AssetSet) ---

	}
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.FromStore)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.FromStore) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSetRange type
func (target *AssetSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetSetRange type
func (target *AssetSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSetRange. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Assets = nil
	} else {
		// --- [begin][read][slice]([]*AssetSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AssetSet, b)
		for i := 0; i < b; i++ {
			var c *AssetSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AssetSet) ---
				d := &AssetSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AssetSet) ---

			}
			a[i] = c
		}
		target.Assets = a
		// --- [end][read][slice]([]*AssetSet) ---

	}
	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.FromStore = e

	return nil
}

//--------------------------------------------------------------------------
//  Breakdown
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Breakdown instance
// into a byte array
func (target *Breakdown) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Breakdown instance
// into a byte array leveraging a predefined context.
func (target *Breakdown) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	buff.WriteFloat64(target.Idle)   // write float64
	buff.WriteFloat64(target.Other)  // write float64
	buff.WriteFloat64(target.System) // write float64
	buff.WriteFloat64(target.User)   // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Breakdown type
func (target *Breakdown) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Breakdown type
func (target *Breakdown) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Breakdown. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.Idle = a

	b := buff.ReadFloat64() // read float64
	target.Other = b

	c := buff.ReadFloat64() // read float64
	target.System = c

	d := buff.ReadFloat64() // read float64
	target.User = d

	return nil
}

//--------------------------------------------------------------------------
//  Cloud
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Cloud instance
// into a byte array
func (target *Cloud) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Cloud instance
// into a byte array leveraging a predefined context.
func (target *Cloud) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.Credit)     // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Cloud type
func (target *Cloud) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Cloud type
func (target *Cloud) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Cloud. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	w := buff.ReadFloat64() // read float64
	target.Credit = w

	return nil
}

//--------------------------------------------------------------------------
//  CloudCost
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCost instance
// into a byte array
func (target *CloudCost) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCost instance
// into a byte array leveraging a predefined context.
func (target *CloudCost) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](CloudCostProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](CloudCostProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	// --- [begin][write][struct](CostMetric) ---
	buff.WriteInt(0) // [compatibility, unused]
	errC := target.ListCost.MarshalBinaryWithContext(ctx)
	if errC != nil {
		return errC
	}
	// --- [end][write][struct](CostMetric) ---

	// --- [begin][write][struct](CostMetric) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.NetCost.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](CostMetric) ---

	// --- [begin][write][struct](CostMetric) ---
	buff.WriteInt(0) // [compatibility, unused]
	errE := target.AmortizedNetCost.MarshalBinaryWithContext(ctx)
	if errE != nil {
		return errE
	}
	// --- [end][write][struct](CostMetric) ---

	// --- [begin][write][struct](CostMetric) ---
	buff.WriteInt(0) // [compatibility, unused]
	errF := target.InvoicedCost.MarshalBinaryWithContext(ctx)
	if errF != nil {
		return errF
	}
	// --- [end][write][struct](CostMetric) ---

	// --- [begin][write][struct](CostMetric) ---
	buff.WriteInt(0) // [compatibility, unused]
	errG := target.AmortizedCost.MarshalBinaryWithContext(ctx)
	if errG != nil {
		return errG
	}
	// --- [end][write][struct](CostMetric) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCost type
func (target *CloudCost) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCost type
func (target *CloudCost) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCost. Expected %d or less, got %d", CloudCostCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](CloudCostProperties) ---
		a := &CloudCostProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](CloudCostProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	b := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := b.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *b
	// --- [end][read][struct](Window) ---

	// --- [begin][read][struct](CostMetric) ---
	c := &CostMetric{}
	buff.ReadInt() // [compatibility, unused]
	errC := c.UnmarshalBinaryWithContext(ctx)
	if errC != nil {
		return errC
	}
	target.ListCost = *c
	// --- [end][read][struct](CostMetric) ---

	// --- [begin][read][struct](CostMetric) ---
	d := &CostMetric{}
	buff.ReadInt() // [compatibility, unused]
	errD := d.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.NetCost = *d
	// --- [end][read][struct](CostMetric) ---

	// --- [begin][read][struct](CostMetric) ---
	e := &CostMetric{}
	buff.ReadInt() // [compatibility, unused]
	errE := e.UnmarshalBinaryWithContext(ctx)
	if errE != nil {
		return errE
	}
	target.AmortizedNetCost = *e
	// --- [end][read][struct](CostMetric) ---

	// --- [begin][read][struct](CostMetric) ---
	f := &CostMetric{}
	buff.ReadInt() // [compatibility, unused]
	errF := f.UnmarshalBinaryWithContext(ctx)
	if errF != nil {
		return errF
	}
	target.InvoicedCost = *f
	// --- [end][read][struct](CostMetric) ---

	// --- [begin][read][struct](CostMetric) ---
	g := &CostMetric{}
	buff.ReadInt() // [compatibility, unused]
	errG := g.UnmarshalBinaryWithContext(ctx)
	if errG != nil {
		return errG
	}
	target.AmortizedCost = *g
	// --- [end][read][struct](CostMetric) ---

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostProperties instance
// into a byte array
func (target *CloudCostProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostProperties instance
// into a byte array leveraging a predefined context.
func (target *CloudCostProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Provider)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Provider) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.AccountID)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.AccountID) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.AccountName)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.AccountName) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.InvoiceEntityID)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.InvoiceEntityID) // write string
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.InvoiceEntityName)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.InvoiceEntityName) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.RegionID)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.RegionID) // write string
	}
	if ctx.IsStringTable() {
		h := ctx.Table.AddOrGet(target.AvailabilityZone)
		buff.WriteInt(h) // write table index
	} else {
		buff.WriteString(target.AvailabilityZone) // write string
	}
	if ctx.IsStringTable() {
		k := ctx.Table.AddOrGet(target.Service)
		buff.WriteInt(k) // write table index
	} else {
		buff.WriteString(target.Service) // write string
	}
	if ctx.IsStringTable() {
		l := ctx.Table.AddOrGet(target.Category)
		buff.WriteInt(l) // write table index
	} else {
		buff.WriteString(target.Category) // write string
	}
	// --- [begin][write][alias](CloudCostLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				m := ctx.Table.AddOrGet(v)
				buff.WriteInt(m) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				n := ctx.Table.AddOrGet(z)
				buff.WriteInt(n) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](CloudCostLabels) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostProperties type
func (target *CloudCostProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostProperties type
func (target *CloudCostProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostProperties. Expected %d or less, got %d", CloudCostCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.ProviderID = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Provider = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.AccountID = g

	// field version check
	if uint8(3) <= version {
		var m string
		if ctx.IsStringTable() {
			n := buff.ReadInt() // read string index
			m = ctx.Table[n]
		} else {
			m = buff.ReadString() // read string
		}
		l := m
		target.AccountName = l

	} else {
		target.AccountName = "" // default
	}

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.InvoiceEntityID = o

	// field version check
	if uint8(3) <= version {
		var s string
		if ctx.IsStringTable() {
			t := buff.ReadInt() // read string index
			s = ctx.Table[t]
		} else {
			s = buff.ReadString() // read string
		}
		r := s
		target.InvoiceEntityName = r

	} else {
		target.InvoiceEntityName = "" // default
	}

	// field version check
	if uint8(3) <= version {
		var w string
		if ctx.IsStringTable() {
			x := buff.ReadInt() // read string index
			w = ctx.Table[x]
		} else {
			w = buff.ReadString() // read string
		}
		u := w
		target.RegionID = u

	} else {
		target.RegionID = "" // default
	}

	// field version check
	if uint8(3) <= version {
		var aa string
		if ctx.IsStringTable() {
			bb := buff.ReadInt() // read string index
			aa = ctx.Table[bb]
		} else {
			aa = buff.ReadString() // read string
		}
		y := aa
		target.AvailabilityZone = y

	} else {
		target.AvailabilityZone = "" // default
	}

	var dd string
	if ctx.IsStringTable() {
		ee := buff.ReadInt() // read string index
		dd = ctx.Table[ee]
	} else {
		dd = buff.ReadString() // read string
	}
	cc := dd
	target.Service = cc

	var gg string
	if ctx.IsStringTable() {
		hh := buff.ReadInt() // read string index
		gg = ctx.Table[hh]
	} else {
		gg = buff.ReadString() // read string
	}
	ff := gg
	target.Category = ff

	// --- [begin][read][alias](CloudCostLabels) ---
	var kk map[string]string
	if buff.ReadUInt8() == uint8(0) {
		kk = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		mm := buff.ReadInt() // map len
		ll := make(map[string]string, mm)
		for i := 0; i < mm; i++ {
			var v string
			var oo string
			if ctx.IsStringTable() {
				pp := buff.ReadInt() // read string index
				oo = ctx.Table[pp]
			} else {
				oo = buff.ReadString() // read string
			}
			nn := oo
			v = nn

			var z string
			var rr string
			if ctx.IsStringTable() {
				ss := buff.ReadInt() // read string index
				rr = ctx.Table[ss]
			} else {
				rr = buff.ReadString() // read string
			}
			qq := rr
			z = qq

			ll[v] = z
		}
		kk = ll
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = CloudCostLabels(kk)
	// --- [end][read][alias](CloudCostLabels) ---

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostSet instance
// into a byte array
func (target *CloudCostSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostSet instance
// into a byte array leveraging a predefined context.
func (target *CloudCostSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostCodecVersion) // version

	if target.CloudCosts == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*CloudCost) ---
		buff.WriteInt(len(target.CloudCosts)) // map length
		for v, z := range target.CloudCosts {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](CloudCost) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := z.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](CloudCost) ---

			}
		}
		// --- [end][write][map](map[string]*CloudCost) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Integration)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Integration) // write string
	}
	if target.AggregationProperties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.AggregationProperties)) // array length
		for i := 0; i < len(target.AggregationProperties); i++ {
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(target.AggregationProperties[i])
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(target.AggregationProperties[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostSet type
func (target *CloudCostSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostSet type
func (target *CloudCostSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostSet. Expected %d or less, got %d", CloudCostCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.CloudCosts = nil
	} else {
		// --- [begin][read][map](map[string]*CloudCost) ---
		b := buff.ReadInt() // map len
		a := make(map[string]*CloudCost, b)
		for i := 0; i < b; i++ {
			var v string
			var d string
			if ctx.IsStringTable() {
				e := buff.ReadInt() // read string index
				d = ctx.Table[e]
			} else {
				d = buff.ReadString() // read string
			}
			c := d
			v = c

			var z *CloudCost
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](CloudCost) ---
				f := &CloudCost{}
				buff.ReadInt() // [compatibility, unused]
				errA := f.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = f
				// --- [end][read][struct](CloudCost) ---

			}
			a[v] = z
		}
		target.CloudCosts = a
		// --- [end][read][map](map[string]*CloudCost) ---

	}
	// --- [begin][read][struct](Window) ---
	g := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := g.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *g
	// --- [end][read][struct](Window) ---

	var k string
	if ctx.IsStringTable() {
		l := buff.ReadInt() // read string index
		k = ctx.Table[l]
	} else {
		k = buff.ReadString() // read string
	}
	h := k
	target.Integration = h

	if buff.ReadUInt8() == uint8(0) {
		target.AggregationProperties = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		n := buff.ReadInt() // array len
		m := make([]string, n)
		for j := 0; j < n; j++ {
			var o string
			var q string
			if ctx.IsStringTable() {
				r := buff.ReadInt() // read string index
				q = ctx.Table[r]
			} else {
				q = buff.ReadString() // read string
			}
			p := q
			o = p

			m[j] = o
		}
		target.AggregationProperties = m
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  CloudCostSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostSetRange instance
// into a byte array
func (target *CloudCostSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostSetRange instance
// into a byte array leveraging a predefined context.
func (target *CloudCostSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostCodecVersion) // version

	if target.CloudCostSets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*CloudCostSet) ---
		buff.WriteInt(len(target.CloudCostSets)) // array length
		for i := 0; i < len(target.CloudCostSets); i++ {
			if target.CloudCostSets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](CloudCostSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.CloudCostSets[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](CloudCostSet) ---

			}
		}
		// --- [end][write][slice]([]*CloudCostSet) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostSetRange type
func (target *CloudCostSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostSetRange type
func (target *CloudCostSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostSetRange. Expected %d or less, got %d", CloudCostCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.CloudCostSets = nil
	} else {
		// --- [begin][read][slice]([]*CloudCostSet) ---
		b := buff.ReadInt() // array len
		a := make([]*CloudCostSet, b)
		for i := 0; i < b; i++ {
			var c *CloudCostSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](CloudCostSet) ---
				d := &CloudCostSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](CloudCostSet) ---

			}
			a[i] = c
		}
		target.CloudCostSets = a
		// --- [end][read][slice]([]*CloudCostSet) ---

	}
	// --- [begin][read][struct](Window) ---
	e := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := e.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *e
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  ClusterManagement
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ClusterManagement instance
// into a byte array
func (target *ClusterManagement) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ClusterManagement instance
// into a byte array leveraging a predefined context.
func (target *ClusterManagement) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.Adjustment) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ClusterManagement type
func (target *ClusterManagement) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ClusterManagement type
func (target *ClusterManagement) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ClusterManagement. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	m := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := m.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *m
	// --- [end][read][struct](Window) ---

	n := buff.ReadFloat64() // read float64
	target.Cost = n

	// field version check
	if uint8(16) <= version {
		o := buff.ReadFloat64() // read float64
		target.Adjustment = o

	} else {
		target.Adjustment = float64(0) // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  CostMetric
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CostMetric instance
// into a byte array
func (target *CostMetric) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CostMetric instance
// into a byte array leveraging a predefined context.
func (target *CostMetric) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostCodecVersion) // version

	buff.WriteFloat64(target.Cost)              // write float64
	buff.WriteFloat64(target.KubernetesPercent) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CostMetric type
func (target *CostMetric) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CostMetric type
func (target *CostMetric) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CostMetric. Expected %d or less, got %d", CloudCostCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.Cost = a

	b := buff.ReadFloat64() // read float64
	target.KubernetesPercent = b

	return nil
}

//--------------------------------------------------------------------------
//  Coverage
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Coverage instance
// into a byte array
func (target *Coverage) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Coverage instance
// into a byte array leveraging a predefined context.
func (target *Coverage) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errA := target.Window.MarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	// --- [end][write][struct](Window) ---

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Type)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Type) // write string
	}
	buff.WriteInt(target.Count) // write int
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.Updated.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for i := 0; i < len(target.Errors); i++ {
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(target.Errors[i])
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(target.Errors[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for j := 0; j < len(target.Warnings); j++ {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(target.Warnings[j])
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(target.Warnings[j]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Coverage type
func (target *Coverage) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Coverage type
func (target *Coverage) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Coverage. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// --- [begin][read][struct](Window) ---
	a := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errA := a.UnmarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	target.Window = *a
	// --- [end][read][struct](Window) ---

	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	target.Type = b

	e := buff.ReadInt() // read int
	target.Count = e

	// --- [begin][read][reference](time.Time) ---
	f := &time.Time{}
	g := buff.ReadInt()    // byte array length
	h := buff.ReadBytes(g) // byte array
	errB := f.UnmarshalBinary(h)
	if errB != nil {
		return errB
	}
	target.Updated = *f
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		l := buff.ReadInt() // array len
		k := make([]string, l)
		for i := 0; i < l; i++ {
			var m string
			var o string
			if ctx.IsStringTable() {
				p := buff.ReadInt() // read string index
				o = ctx.Table[p]
			} else {
				o = buff.ReadString() // read string
			}
			n := o
			m = n

			k[i] = m
		}
		target.Errors = k
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		r := buff.ReadInt() // array len
		q := make([]string, r)
		for j := 0; j < r; j++ {
			var s string
			var u string
			if ctx.IsStringTable() {
				w := buff.ReadInt() // read string index
				u = ctx.Table[w]
			} else {
				u = buff.ReadString() // read string
			}
			t := u
			s = t

			q[j] = s
		}
		target.Warnings = q
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  CoverageSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CoverageSet instance
// into a byte array
func (target *CoverageSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CoverageSet instance
// into a byte array leveraging a predefined context.
func (target *CoverageSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errA := target.Window.MarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	// --- [end][write][struct](Window) ---

	if target.Items == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Coverage) ---
		buff.WriteInt(len(target.Items)) // map length
		for v, z := range target.Items {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Coverage) ---
				buff.WriteInt(0) // [compatibility, unused]
				errB := z.MarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				// --- [end][write][struct](Coverage) ---

			}
		}
		// --- [end][write][map](map[string]*Coverage) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CoverageSet type
func (target *CoverageSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CoverageSet type
func (target *CoverageSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CoverageSet. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// --- [begin][read][struct](Window) ---
	a := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errA := a.UnmarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	target.Window = *a
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Items = nil
	} else {
		// --- [begin][read][map](map[string]*Coverage) ---
		c := buff.ReadInt() // map len
		b := make(map[string]*Coverage, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z *Coverage
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](Coverage) ---
				g := &Coverage{}
				buff.ReadInt() // [compatibility, unused]
				errB := g.UnmarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				z = g
				// --- [end][read][struct](Coverage) ---

			}
			b[v] = z
		}
		target.Items = b
		// --- [end][read][map](map[string]*Coverage) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  Disk
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Disk instance
// into a byte array
func (target *Disk) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Disk instance
// into a byte array leveraging a predefined context.
func (target *Disk) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.ByteHours)  // write float64
	buff.WriteFloat64(target.Local)      // write float64
	if target.Breakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		buff.WriteInt(0) // [compatibility, unused]
		errE := target.Breakdown.MarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		// --- [end][write][struct](Breakdown) ---

	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.StorageClass)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.StorageClass) // write string
	}
	if target.ByteHoursUsed == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		buff.WriteFloat64(*target.ByteHoursUsed) // write float64
	}
	if target.ByteUsageMax == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		buff.WriteFloat64(*target.ByteUsageMax) // write float64
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.VolumeName)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.VolumeName) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.ClaimName)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.ClaimName) // write string
	}
	if ctx.IsStringTable() {
		h := ctx.Table.AddOrGet(target.ClaimNamespace)
		buff.WriteInt(h) // write table index
	} else {
		buff.WriteString(target.ClaimNamespace) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Disk type
func (target *Disk) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Disk type
func (target *Disk) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Disk. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	w := buff.ReadFloat64() // read float64
	target.ByteHours = w

	x := buff.ReadFloat64() // read float64
	target.Local = x

	if buff.ReadUInt8() == uint8(0) {
		target.Breakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		y := &Breakdown{}
		buff.ReadInt() // [compatibility, unused]
		errE := y.UnmarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		target.Breakdown = y
		// --- [end][read][struct](Breakdown) ---

	}
	// field version check
	if uint8(17) <= version {
		var bb string
		if ctx.IsStringTable() {
			cc := buff.ReadInt() // read string index
			bb = ctx.Table[cc]
		} else {
			bb = buff.ReadString() // read string
		}
		aa := bb
		target.StorageClass = aa

	} else {
		target.StorageClass = "" // default
	}

	// field version check
	if uint8(18) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.ByteHoursUsed = nil
		} else {
			dd := buff.ReadFloat64() // read float64
			target.ByteHoursUsed = &dd

		}
	} else {
		target.ByteHoursUsed = nil

	}

	// field version check
	if uint8(18) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.ByteUsageMax = nil
		} else {
			ee := buff.ReadFloat64() // read float64
			target.ByteUsageMax = &ee

		}
	} else {
		target.ByteUsageMax = nil

	}

	// field version check
	if uint8(18) <= version {
		var gg string
		if ctx.IsStringTable() {
			hh := buff.ReadInt() // read string index
			gg = ctx.Table[hh]
		} else {
			gg = buff.ReadString() // read string
		}
		ff := gg
		target.VolumeName = ff

	} else {
		target.VolumeName = "" // default
	}

	// field version check
	if uint8(18) <= version {
		var ll string
		if ctx.IsStringTable() {
			mm := buff.ReadInt() // read string index
			ll = ctx.Table[mm]
		} else {
			ll = buff.ReadString() // read string
		}
		kk := ll
		target.ClaimName = kk

	} else {
		target.ClaimName = "" // default
	}

	// field version check
	if uint8(18) <= version {
		var oo string
		if ctx.IsStringTable() {
			pp := buff.ReadInt() // read string index
			oo = ctx.Table[pp]
		} else {
			oo = buff.ReadString() // read string
		}
		nn := oo
		target.ClaimNamespace = nn

	} else {
		target.ClaimNamespace = "" // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  LbAllocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this LbAllocation instance
// into a byte array
func (target *LbAllocation) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this LbAllocation instance
// into a byte array leveraging a predefined context.
func (target *LbAllocation) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Service)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Service) // write string
	}
	buff.WriteFloat64(target.Cost) // write float64
	buff.WriteBool(target.Private) // write bool
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Ip)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Ip) // write string
	}
	buff.WriteFloat64(target.Hours) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the LbAllocation type
func (target *LbAllocation) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the LbAllocation type
func (target *LbAllocation) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling LbAllocation. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Service = a

	d := buff.ReadFloat64() // read float64
	target.Cost = d

	e := buff.ReadBool() // read bool
	target.Private = e

	// field version check
	if uint8(19) <= version {
		var g string
		if ctx.IsStringTable() {
			h := buff.ReadInt() // read string index
			g = ctx.Table[h]
		} else {
			g = buff.ReadString() // read string
		}
		f := g
		target.Ip = f

	} else {
		target.Ip = "" // default
	}

	// field version check
	if uint8(21) <= version {
		k := buff.ReadFloat64() // read float64
		target.Hours = k

	} else {
		target.Hours = float64(0) // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  LoadBalancer
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this LoadBalancer instance
// into a byte array
func (target *LoadBalancer) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this LoadBalancer instance
// into a byte array leveraging a predefined context.
func (target *LoadBalancer) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteBool(target.Private)       // write bool
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.Ip)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.Ip) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the LoadBalancer type
func (target *LoadBalancer) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the LoadBalancer type
func (target *LoadBalancer) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling LoadBalancer. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	// field version check
	if uint8(20) <= version {
		w := buff.ReadBool() // read bool
		target.Private = w

	} else {
		target.Private = false // default
	}

	// field version check
	if uint8(21) <= version {
		var y string
		if ctx.IsStringTable() {
			aa := buff.ReadInt() // read string index
			y = ctx.Table[aa]
		} else {
			y = buff.ReadString() // read string
		}
		x := y
		target.Ip = x

	} else {
		target.Ip = "" // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  Network
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Network instance
// into a byte array
func (target *Network) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Network instance
// into a byte array leveraging a predefined context.
func (target *Network) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Network type
func (target *Network) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Network type
func (target *Network) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Network. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  Node
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Node instance
// into a byte array
func (target *Node) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Node instance
// into a byte array leveraging a predefined context.
func (target *Node) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.NodeType)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.NodeType) // write string
	}
	buff.WriteFloat64(target.CPUCoreHours) // write float64
	buff.WriteFloat64(target.RAMByteHours) // write float64
	buff.WriteFloat64(target.GPUHours)     // write float64
	if target.CPUBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		buff.WriteInt(0) // [compatibility, unused]
		errE := target.CPUBreakdown.MarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		// --- [end][write][struct](Breakdown) ---

	}
	if target.RAMBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		buff.WriteInt(0) // [compatibility, unused]
		errF := target.RAMBreakdown.MarshalBinaryWithContext(ctx)
		if errF != nil {
			return errF
		}
		// --- [end][write][struct](Breakdown) ---

	}
	buff.WriteFloat64(target.CPUCost)     // write float64
	buff.WriteFloat64(target.GPUCost)     // write float64
	buff.WriteFloat64(target.GPUCount)    // write float64
	buff.WriteFloat64(target.RAMCost)     // write float64
	buff.WriteFloat64(target.Discount)    // write float64
	buff.WriteFloat64(target.Preemptible) // write float64
	if target.Overhead == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](NodeOverhead) ---
		buff.WriteInt(0) // [compatibility, unused]
		errG := target.Overhead.MarshalBinaryWithContext(ctx)
		if errG != nil {
			return errG
		}
		// --- [end][write][struct](NodeOverhead) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Node type
func (target *Node) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Node type
func (target *Node) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Node. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.NodeType = u

	y := buff.ReadFloat64() // read float64
	target.CPUCoreHours = y

	aa := buff.ReadFloat64() // read float64
	target.RAMByteHours = aa

	bb := buff.ReadFloat64() // read float64
	target.GPUHours = bb

	if buff.ReadUInt8() == uint8(0) {
		target.CPUBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		cc := &Breakdown{}
		buff.ReadInt() // [compatibility, unused]
		errE := cc.UnmarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		target.CPUBreakdown = cc
		// --- [end][read][struct](Breakdown) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.RAMBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		dd := &Breakdown{}
		buff.ReadInt() // [compatibility, unused]
		errF := dd.UnmarshalBinaryWithContext(ctx)
		if errF != nil {
			return errF
		}
		target.RAMBreakdown = dd
		// --- [end][read][struct](Breakdown) ---

	}
	ee := buff.ReadFloat64() // read float64
	target.CPUCost = ee

	ff := buff.ReadFloat64() // read float64
	target.GPUCost = ff

	gg := buff.ReadFloat64() // read float64
	target.GPUCount = gg

	hh := buff.ReadFloat64() // read float64
	target.RAMCost = hh

	kk := buff.ReadFloat64() // read float64
	target.Discount = kk

	ll := buff.ReadFloat64() // read float64
	target.Preemptible = ll

	// field version check
	if uint8(19) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Overhead = nil
		} else {
			// --- [begin][read][struct](NodeOverhead) ---
			mm := &NodeOverhead{}
			buff.ReadInt() // [compatibility, unused]
			errG := mm.UnmarshalBinaryWithContext(ctx)
			if errG != nil {
				return errG
			}
			target.Overhead = mm
			// --- [end][read][struct](NodeOverhead) ---

		}
	} else {
		target.Overhead = nil

	}

	return nil
}

//--------------------------------------------------------------------------
//  NodeOverhead
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this NodeOverhead instance
// into a byte array
func (target *NodeOverhead) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this NodeOverhead instance
// into a byte array leveraging a predefined context.
func (target *NodeOverhead) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	buff.WriteFloat64(target.CpuOverheadFraction)  // write float64
	buff.WriteFloat64(target.RamOverheadFraction)  // write float64
	buff.WriteFloat64(target.OverheadCostFraction) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the NodeOverhead type
func (target *NodeOverhead) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the NodeOverhead type
func (target *NodeOverhead) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling NodeOverhead. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.CpuOverheadFraction = a

	b := buff.ReadFloat64() // read float64
	target.RamOverheadFraction = b

	c := buff.ReadFloat64() // read float64
	target.OverheadCostFraction = c

	return nil
}

//--------------------------------------------------------------------------
//  PVAllocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this PVAllocation instance
// into a byte array
func (target *PVAllocation) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this PVAllocation instance
// into a byte array leveraging a predefined context.
func (target *PVAllocation) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	buff.WriteFloat64(target.ByteHours) // write float64
	buff.WriteFloat64(target.Cost)      // write float64
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the PVAllocation type
func (target *PVAllocation) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the PVAllocation type
func (target *PVAllocation) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling PVAllocation. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.ByteHours = a

	b := buff.ReadFloat64() // read float64
	target.Cost = b

	// field version check
	if uint8(20) <= version {
		var d string
		if ctx.IsStringTable() {
			e := buff.ReadInt() // read string index
			d = ctx.Table[e]
		} else {
			d = buff.ReadString() // read string
		}
		c := d
		target.ProviderID = c

	} else {
		target.ProviderID = "" // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  PVKey
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this PVKey instance
// into a byte array
func (target *PVKey) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this PVKey instance
// into a byte array leveraging a predefined context.
func (target *PVKey) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Cluster)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Cluster) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the PVKey type
func (target *PVKey) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the PVKey type
func (target *PVKey) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling PVKey. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Cluster = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Name = d

	return nil
}

//--------------------------------------------------------------------------
//  RawAllocationOnlyData
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this RawAllocationOnlyData instance
// into a byte array
func (target *RawAllocationOnlyData) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this RawAllocationOnlyData instance
// into a byte array leveraging a predefined context.
func (target *RawAllocationOnlyData) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	buff.WriteFloat64(target.CPUCoreUsageMax)  // write float64
	buff.WriteFloat64(target.RAMBytesUsageMax) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the RawAllocationOnlyData type
func (target *RawAllocationOnlyData) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the RawAllocationOnlyData type
func (target *RawAllocationOnlyData) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling RawAllocationOnlyData. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.CPUCoreUsageMax = a

	b := buff.ReadFloat64() // read float64
	target.RAMBytesUsageMax = b

	return nil
}

//--------------------------------------------------------------------------
//  SharedAsset
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this SharedAsset instance
// into a byte array
func (target *SharedAsset) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this SharedAsset instance
// into a byte array leveraging a predefined context.
func (target *SharedAsset) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the SharedAsset type
func (target *SharedAsset) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the SharedAsset type
func (target *SharedAsset) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling SharedAsset. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][struct](Window) ---
	m := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := m.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *m
	// --- [end][read][struct](Window) ---

	n := buff.ReadFloat64() // read float64
	target.Cost = n

	return nil
}

//--------------------------------------------------------------------------
//  Window
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Window instance
// into a byte array
func (target *Window) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Window instance
// into a byte array leveraging a predefined context.
func (target *Window) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if target.start == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		a, errA := target.start.MarshalBinary()
		if errA != nil {
			return errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][reference](time.Time) ---

	}
	if target.end == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		b, errB := target.end.MarshalBinary()
		if errB != nil {
			return errB
		}
		buff.WriteInt(len(b))
		buff.WriteBytes(b)
		// --- [end][write][reference](time.Time) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Window. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.start = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.start = a
		// --- [end][read][reference](time.Time) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.end = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		d := &time.Time{}
		e := buff.ReadInt()    // byte array length
		f := buff.ReadBytes(e) // byte array
		errB := d.UnmarshalBinary(f)
		if errB != nil {
			return errB
		}
		target.end = d
		// --- [end][read][reference](time.Time) ---

	}
	return nil
}
