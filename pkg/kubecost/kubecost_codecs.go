////////////////////////////////////////////////////////////////////////////////
//
//                             DO NOT MODIFY
//
//                          ┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻
//
//
//            This source file was automatically generated by bingen.
//
////////////////////////////////////////////////////////////////////////////////

package kubecost

import (
	"encoding"
	"fmt"
	"reflect"
	"strings"
	"time"

	util "github.com/kubecost/cost-model/pkg/util"
)

// GeneratorPackageName is the package the generator is targetting
const GeneratorPackageName string = "kubecost"

//--------------------------------------------------------------------------
//  Type Map
//--------------------------------------------------------------------------

// Generated type map for resolving interface implementations to
// to concrete types
var typeMap map[string]reflect.Type = map[string]reflect.Type{
	"Allocation":         reflect.TypeOf((*Allocation)(nil)).Elem(),
	"AllocationSet":      reflect.TypeOf((*AllocationSet)(nil)).Elem(),
	"AllocationSetRange": reflect.TypeOf((*AllocationSetRange)(nil)).Elem(),
	"Any":                reflect.TypeOf((*Any)(nil)).Elem(),
	"AssetProperties":    reflect.TypeOf((*AssetProperties)(nil)).Elem(),
	"AssetSet":           reflect.TypeOf((*AssetSet)(nil)).Elem(),
	"AssetSetRange":      reflect.TypeOf((*AssetSetRange)(nil)).Elem(),
	"Breakdown":          reflect.TypeOf((*Breakdown)(nil)).Elem(),
	"Cloud":              reflect.TypeOf((*Cloud)(nil)).Elem(),
	"ClusterManagement":  reflect.TypeOf((*ClusterManagement)(nil)).Elem(),
	"Disk":               reflect.TypeOf((*Disk)(nil)).Elem(),
	"LoadBalancer":       reflect.TypeOf((*LoadBalancer)(nil)).Elem(),
	"Network":            reflect.TypeOf((*Network)(nil)).Elem(),
	"Node":               reflect.TypeOf((*Node)(nil)).Elem(),
	"SharedAsset":        reflect.TypeOf((*SharedAsset)(nil)).Elem(),
	"Window":             reflect.TypeOf((*Window)(nil)).Elem(),
}

//--------------------------------------------------------------------------
//  Type Helpers
//--------------------------------------------------------------------------

// typeToString determines the basic properties of the type, the qualifier, package path, and
// type name, and returns the qualified type
func typeToString(f interface{}) string {
	qual := ""
	t := reflect.TypeOf(f)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
		qual = "*"
	}

	return fmt.Sprintf("%s%s.%s", qual, t.PkgPath(), t.Name())
}

// resolveType uses the name of a type and returns the package, base type name, and whether
// or not it's a pointer.
func resolveType(t string) (pkg string, name string, isPtr bool) {
	isPtr = t[:1] == "*"
	if isPtr {
		t = t[1:]
	}

	slashIndex := strings.LastIndex(t, "/")
	if slashIndex >= 0 {
		t = t[slashIndex+1:]
	}
	parts := strings.Split(t, ".")
	if parts[0] == GeneratorPackageName {
		parts[0] = ""
	}

	pkg = parts[0]
	name = parts[1]
	return
}

//--------------------------------------------------------------------------
//  Allocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Allocation instance
// into a byte array
func (target *Allocation) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	buff.WriteString(target.Name) // write string
	// --- [begin][write][reference](Properties) ---
	a, errA := target.Properties.MarshalBinary()
	if errA != nil {
		return nil, errA
	}
	buff.WriteInt(len(a))
	buff.WriteBytes(a)
	// --- [end][write][reference](Properties) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.Start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.End.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	buff.WriteFloat64(target.Minutes) // write float64
	// --- [begin][write][reference](time.Time) ---
	d, errD := target.ActiveStart.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	buff.WriteFloat64(target.CPUCoreHours)    // write float64
	buff.WriteFloat64(target.CPUCost)         // write float64
	buff.WriteFloat64(target.CPUEfficiency)   // write float64
	buff.WriteFloat64(target.GPUHours)        // write float64
	buff.WriteFloat64(target.GPUCost)         // write float64
	buff.WriteFloat64(target.NetworkCost)     // write float64
	buff.WriteFloat64(target.PVByteHours)     // write float64
	buff.WriteFloat64(target.PVCost)          // write float64
	buff.WriteFloat64(target.RAMByteHours)    // write float64
	buff.WriteFloat64(target.RAMCost)         // write float64
	buff.WriteFloat64(target.RAMEfficiency)   // write float64
	buff.WriteFloat64(target.SharedCost)      // write float64
	buff.WriteFloat64(target.TotalCost)       // write float64
	buff.WriteFloat64(target.TotalEfficiency) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Allocation type
func (target *Allocation) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Allocation. Expected 3, got %d", version)
	}

	a := buff.ReadString() // read string
	target.Name = a

	// --- [begin][read][reference](Properties) ---
	b := &Properties{}
	c := buff.ReadInt()    // byte array length
	d := buff.ReadBytes(c) // byte array
	errA := b.UnmarshalBinary(d)
	if errA != nil {
		return errA
	}
	target.Properties = *b
	// --- [end][read][reference](Properties) ---

	// --- [begin][read][reference](time.Time) ---
	e := &time.Time{}
	f := buff.ReadInt()    // byte array length
	g := buff.ReadBytes(f) // byte array
	errB := e.UnmarshalBinary(g)
	if errB != nil {
		return errB
	}
	target.Start = *e
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errC := h.UnmarshalBinary(m)
	if errC != nil {
		return errC
	}
	target.End = *h
	// --- [end][read][reference](time.Time) ---

	n := buff.ReadFloat64() // read float64
	target.Minutes = n

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errD := o.UnmarshalBinary(q)
	if errD != nil {
		return errD
	}
	target.ActiveStart = *o
	// --- [end][read][reference](time.Time) ---

	r := buff.ReadFloat64() // read float64
	target.CPUCoreHours = r

	s := buff.ReadFloat64() // read float64
	target.CPUCost = s

	t := buff.ReadFloat64() // read float64
	target.CPUEfficiency = t

	u := buff.ReadFloat64() // read float64
	target.GPUHours = u

	w := buff.ReadFloat64() // read float64
	target.GPUCost = w

	x := buff.ReadFloat64() // read float64
	target.NetworkCost = x

	y := buff.ReadFloat64() // read float64
	target.PVByteHours = y

	z := buff.ReadFloat64() // read float64
	target.PVCost = z

	aa := buff.ReadFloat64() // read float64
	target.RAMByteHours = aa

	bb := buff.ReadFloat64() // read float64
	target.RAMCost = bb

	cc := buff.ReadFloat64() // read float64
	target.RAMEfficiency = cc

	dd := buff.ReadFloat64() // read float64
	target.SharedCost = dd

	ee := buff.ReadFloat64() // read float64
	target.TotalCost = ee

	ff := buff.ReadFloat64() // read float64
	target.TotalEfficiency = ff

	return nil
}

//--------------------------------------------------------------------------
//  AllocationSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSet instance
// into a byte array
func (target *AllocationSet) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Allocation) ---
		buff.WriteInt(len(target.allocations)) // map length
		for k, v := range target.allocations {
			buff.WriteString(k) // write string
			if v == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Allocation) ---
				a, errA := v.MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteInt(len(a))
				buff.WriteBytes(a)
				// --- [end][write][struct](Allocation) ---

			}
		}
		// --- [end][write][map](map[string]*Allocation) ---

	}
	if target.idleKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.idleKeys)) // map length
		for kk, vv := range target.idleKeys {
			buff.WriteString(kk) // write string
			buff.WriteBool(vv)   // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	// --- [begin][write][struct](Window) ---
	b, errB := target.Window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSet type
func (target *AllocationSet) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSet. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.allocations = nil
	} else {
		// --- [begin][read][map](map[string]*Allocation) ---
		a := make(map[string]*Allocation)
		b := buff.ReadInt() // map len
		for i := 0; i < b; i++ {
			var k string
			c := buff.ReadString() // read string
			k = c

			var v *Allocation
			if buff.ReadUInt8() == uint8(0) {
				v = nil
			} else {
				// --- [begin][read][struct](Allocation) ---
				d := &Allocation{}
				e := buff.ReadInt()    // byte array length
				f := buff.ReadBytes(e) // byte array
				errA := d.UnmarshalBinary(f)
				if errA != nil {
					return errA
				}
				v = d
				// --- [end][read][struct](Allocation) ---

			}
			a[k] = v
		}
		target.allocations = a
		// --- [end][read][map](map[string]*Allocation) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.idleKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		g := make(map[string]bool)
		h := buff.ReadInt() // map len
		for j := 0; j < h; j++ {
			var kk string
			l := buff.ReadString() // read string
			kk = l

			var vv bool
			m := buff.ReadBool() // read bool
			vv = m

			g[kk] = vv
		}
		target.idleKeys = g
		// --- [end][read][map](map[string]bool) ---

	}
	// --- [begin][read][struct](Window) ---
	n := &Window{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errB := n.UnmarshalBinary(p)
	if errB != nil {
		return errB
	}
	target.Window = *n
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  AllocationSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSetRange instance
// into a byte array
func (target *AllocationSetRange) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AllocationSet) ---
		buff.WriteInt(len(target.allocations)) // array length
		for i := 0; i < len(target.allocations); i++ {
			if target.allocations[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AllocationSet) ---
				a, errA := target.allocations[i].MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteInt(len(a))
				buff.WriteBytes(a)
				// --- [end][write][struct](AllocationSet) ---

			}
		}
		// --- [end][write][slice]([]*AllocationSet) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSetRange type
func (target *AllocationSetRange) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSetRange. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.allocations = nil
	} else {
		// --- [begin][read][slice]([]*AllocationSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AllocationSet, b)
		for i := 0; i < b; i++ {
			var c *AllocationSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AllocationSet) ---
				d := &AllocationSet{}
				e := buff.ReadInt()    // byte array length
				f := buff.ReadBytes(e) // byte array
				errA := d.UnmarshalBinary(f)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AllocationSet) ---

			}
			a[i] = c
		}
		target.allocations = a
		// --- [end][read][slice]([]*AllocationSet) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  Any
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Any instance
// into a byte array
func (target *Any) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Any type
func (target *Any) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Any. Expected 3, got %d", version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		b := make(map[string]string)
		c := buff.ReadInt() // map len
		for i := 0; i < c; i++ {
			var k string
			d := buff.ReadString() // read string
			k = d

			var v string
			e := buff.ReadString() // read string
			v = e

			b[k] = v
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	l := &time.Time{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.start = *l
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errC := o.UnmarshalBinary(q)
	if errC != nil {
		return errC
	}
	target.end = *o
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errD := r.UnmarshalBinary(t)
	if errD != nil {
		return errD
	}
	target.window = *r
	// --- [end][read][struct](Window) ---

	u := buff.ReadFloat64() // read float64
	target.adjustment = u

	w := buff.ReadFloat64() // read float64
	target.Cost = w

	return nil
}

//--------------------------------------------------------------------------
//  AssetProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetProperties instance
// into a byte array
func (target *AssetProperties) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	buff.WriteString(target.Category)   // write string
	buff.WriteString(target.Provider)   // write string
	buff.WriteString(target.Account)    // write string
	buff.WriteString(target.Project)    // write string
	buff.WriteString(target.Service)    // write string
	buff.WriteString(target.Cluster)    // write string
	buff.WriteString(target.Name)       // write string
	buff.WriteString(target.ProviderID) // write string
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetProperties type
func (target *AssetProperties) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling AssetProperties. Expected 3, got %d", version)
	}

	a := buff.ReadString() // read string
	target.Category = a

	b := buff.ReadString() // read string
	target.Provider = b

	c := buff.ReadString() // read string
	target.Account = c

	d := buff.ReadString() // read string
	target.Project = d

	e := buff.ReadString() // read string
	target.Service = e

	f := buff.ReadString() // read string
	target.Cluster = f

	g := buff.ReadString() // read string
	target.Name = g

	h := buff.ReadString() // read string
	target.ProviderID = h

	return nil
}

//--------------------------------------------------------------------------
//  AssetSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSet instance
// into a byte array
func (target *AssetSet) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]Asset) ---
		buff.WriteInt(len(target.assets)) // map length
		for k, v := range target.assets {
			buff.WriteString(k) // write string
			if v == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][interface](Asset) ---
				a := reflect.ValueOf(v).Interface()
				b, okA := a.(encoding.BinaryMarshaler)
				if !okA {
					return nil, fmt.Errorf("Type: %s does not implement encoding.BinaryMarshaler", typeToString(v))
				}
				c, errA := b.MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteString(typeToString(v))
				buff.WriteInt(len(c))
				buff.WriteBytes(c)
				// --- [end][write][interface](Asset) ---

			}
		}
		// --- [end][write][map](map[string]Asset) ---

	}
	if target.props == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]AssetProperty) ---
		buff.WriteInt(len(target.props)) // array length
		for i := 0; i < len(target.props); i++ {
			// --- [begin][write][alias](AssetProperty) ---
			buff.WriteString(string(target.props[i])) // write string
			// --- [end][write][alias](AssetProperty) ---

		}
		// --- [end][write][slice]([]AssetProperty) ---

	}
	// --- [begin][write][struct](Window) ---
	d, errB := target.Window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSet type
func (target *AssetSet) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSet. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.assets = nil
	} else {
		// --- [begin][read][map](map[string]Asset) ---
		a := make(map[string]Asset)
		b := buff.ReadInt() // map len
		for i := 0; i < b; i++ {
			var k string
			c := buff.ReadString() // read string
			k = c

			var v Asset
			if buff.ReadUInt8() == uint8(0) {
				v = nil
			} else {
				// --- [begin][read][interface](Asset) ---
				d := buff.ReadString()
				_, e, _ := resolveType(d)
				if _, ok := typeMap[e]; !ok {
					return fmt.Errorf("Unknown Type: %s", e)
				}
				f, okA := reflect.New(typeMap[e]).Interface().(interface{ UnmarshalBinary([]byte) error })
				if !okA {
					return fmt.Errorf("Type: %s does not implement UnmarshalBinary([]byte) error", e)
				}
				g := buff.ReadInt()    // byte array length
				h := buff.ReadBytes(g) // byte array
				errA := f.UnmarshalBinary(h)
				if errA != nil {
					return errA
				}
				v = f.(Asset)
				// --- [end][read][interface](Asset) ---

			}
			a[k] = v
		}
		target.assets = a
		// --- [end][read][map](map[string]Asset) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.props = nil
	} else {
		// --- [begin][read][slice]([]AssetProperty) ---
		m := buff.ReadInt() // array len
		l := make([]AssetProperty, m)
		for j := 0; j < m; j++ {
			// --- [begin][read][alias](AssetProperty) ---
			var o string
			p := buff.ReadString() // read string
			o = p

			n := AssetProperty(o)
			// --- [end][read][alias](AssetProperty) ---

			l[j] = n
		}
		target.props = l
		// --- [end][read][slice]([]AssetProperty) ---

	}
	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errB := q.UnmarshalBinary(s)
	if errB != nil {
		return errB
	}
	target.Window = *q
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  AssetSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSetRange instance
// into a byte array
func (target *AssetSetRange) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AssetSet) ---
		buff.WriteInt(len(target.assets)) // array length
		for i := 0; i < len(target.assets); i++ {
			if target.assets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AssetSet) ---
				a, errA := target.assets[i].MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteInt(len(a))
				buff.WriteBytes(a)
				// --- [end][write][struct](AssetSet) ---

			}
		}
		// --- [end][write][slice]([]*AssetSet) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSetRange type
func (target *AssetSetRange) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSetRange. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.assets = nil
	} else {
		// --- [begin][read][slice]([]*AssetSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AssetSet, b)
		for i := 0; i < b; i++ {
			var c *AssetSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AssetSet) ---
				d := &AssetSet{}
				e := buff.ReadInt()    // byte array length
				f := buff.ReadBytes(e) // byte array
				errA := d.UnmarshalBinary(f)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AssetSet) ---

			}
			a[i] = c
		}
		target.assets = a
		// --- [end][read][slice]([]*AssetSet) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  Breakdown
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Breakdown instance
// into a byte array
func (target *Breakdown) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	buff.WriteFloat64(target.Idle)   // write float64
	buff.WriteFloat64(target.Other)  // write float64
	buff.WriteFloat64(target.System) // write float64
	buff.WriteFloat64(target.User)   // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Breakdown type
func (target *Breakdown) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Breakdown. Expected 3, got %d", version)
	}

	a := buff.ReadFloat64() // read float64
	target.Idle = a

	b := buff.ReadFloat64() // read float64
	target.Other = b

	c := buff.ReadFloat64() // read float64
	target.System = c

	d := buff.ReadFloat64() // read float64
	target.User = d

	return nil
}

//--------------------------------------------------------------------------
//  Cloud
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Cloud instance
// into a byte array
func (target *Cloud) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Cloud type
func (target *Cloud) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Cloud. Expected 3, got %d", version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		b := make(map[string]string)
		c := buff.ReadInt() // map len
		for i := 0; i < c; i++ {
			var k string
			d := buff.ReadString() // read string
			k = d

			var v string
			e := buff.ReadString() // read string
			v = e

			b[k] = v
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	l := &time.Time{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.start = *l
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errC := o.UnmarshalBinary(q)
	if errC != nil {
		return errC
	}
	target.end = *o
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errD := r.UnmarshalBinary(t)
	if errD != nil {
		return errD
	}
	target.window = *r
	// --- [end][read][struct](Window) ---

	u := buff.ReadFloat64() // read float64
	target.adjustment = u

	w := buff.ReadFloat64() // read float64
	target.Cost = w

	return nil
}

//--------------------------------------------------------------------------
//  ClusterManagement
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ClusterManagement instance
// into a byte array
func (target *ClusterManagement) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	b, errB := target.window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ClusterManagement type
func (target *ClusterManagement) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling ClusterManagement. Expected 3, got %d", version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		b := make(map[string]string)
		c := buff.ReadInt() // map len
		for i := 0; i < c; i++ {
			var k string
			d := buff.ReadString() // read string
			k = d

			var v string
			e := buff.ReadString() // read string
			v = e

			b[k] = v
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	l := &Window{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.window = *l
	// --- [end][read][struct](Window) ---

	o := buff.ReadFloat64() // read float64
	target.Cost = o

	return nil
}

//--------------------------------------------------------------------------
//  Disk
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Disk instance
// into a byte array
func (target *Disk) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.ByteHours)  // write float64
	buff.WriteFloat64(target.Local)      // write float64
	if target.Breakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		e, errE := target.Breakdown.MarshalBinary()
		if errE != nil {
			return nil, errE
		}
		buff.WriteInt(len(e))
		buff.WriteBytes(e)
		// --- [end][write][struct](Breakdown) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Disk type
func (target *Disk) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Disk. Expected 3, got %d", version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		b := make(map[string]string)
		c := buff.ReadInt() // map len
		for i := 0; i < c; i++ {
			var k string
			d := buff.ReadString() // read string
			k = d

			var v string
			e := buff.ReadString() // read string
			v = e

			b[k] = v
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	l := &time.Time{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.start = *l
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errC := o.UnmarshalBinary(q)
	if errC != nil {
		return errC
	}
	target.end = *o
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errD := r.UnmarshalBinary(t)
	if errD != nil {
		return errD
	}
	target.window = *r
	// --- [end][read][struct](Window) ---

	u := buff.ReadFloat64() // read float64
	target.adjustment = u

	w := buff.ReadFloat64() // read float64
	target.Cost = w

	x := buff.ReadFloat64() // read float64
	target.ByteHours = x

	y := buff.ReadFloat64() // read float64
	target.Local = y

	if buff.ReadUInt8() == uint8(0) {
		target.Breakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		z := &Breakdown{}
		aa := buff.ReadInt()     // byte array length
		bb := buff.ReadBytes(aa) // byte array
		errE := z.UnmarshalBinary(bb)
		if errE != nil {
			return errE
		}
		target.Breakdown = z
		// --- [end][read][struct](Breakdown) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  LoadBalancer
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this LoadBalancer instance
// into a byte array
func (target *LoadBalancer) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the LoadBalancer type
func (target *LoadBalancer) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling LoadBalancer. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		e := make(map[string]string)
		f := buff.ReadInt() // map len
		for i := 0; i < f; i++ {
			var k string
			g := buff.ReadString() // read string
			k = g

			var v string
			h := buff.ReadString() // read string
			v = h

			e[k] = v
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	l := &time.Time{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.start = *l
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errC := o.UnmarshalBinary(q)
	if errC != nil {
		return errC
	}
	target.end = *o
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errD := r.UnmarshalBinary(t)
	if errD != nil {
		return errD
	}
	target.window = *r
	// --- [end][read][struct](Window) ---

	u := buff.ReadFloat64() // read float64
	target.adjustment = u

	w := buff.ReadFloat64() // read float64
	target.Cost = w

	return nil
}

//--------------------------------------------------------------------------
//  Network
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Network instance
// into a byte array
func (target *Network) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Network type
func (target *Network) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Network. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		e := make(map[string]string)
		f := buff.ReadInt() // map len
		for i := 0; i < f; i++ {
			var k string
			g := buff.ReadString() // read string
			k = g

			var v string
			h := buff.ReadString() // read string
			v = h

			e[k] = v
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	l := &time.Time{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.start = *l
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errC := o.UnmarshalBinary(q)
	if errC != nil {
		return errC
	}
	target.end = *o
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errD := r.UnmarshalBinary(t)
	if errD != nil {
		return errD
	}
	target.window = *r
	// --- [end][read][struct](Window) ---

	u := buff.ReadFloat64() // read float64
	target.adjustment = u

	w := buff.ReadFloat64() // read float64
	target.Cost = w

	return nil
}

//--------------------------------------------------------------------------
//  Node
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Node instance
// into a byte array
func (target *Node) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment)   // write float64
	buff.WriteString(target.NodeType)      // write string
	buff.WriteFloat64(target.CPUCoreHours) // write float64
	buff.WriteFloat64(target.RAMByteHours) // write float64
	if target.CPUBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		e, errE := target.CPUBreakdown.MarshalBinary()
		if errE != nil {
			return nil, errE
		}
		buff.WriteInt(len(e))
		buff.WriteBytes(e)
		// --- [end][write][struct](Breakdown) ---

	}
	if target.RAMBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		f, errF := target.RAMBreakdown.MarshalBinary()
		if errF != nil {
			return nil, errF
		}
		buff.WriteInt(len(f))
		buff.WriteBytes(f)
		// --- [end][write][struct](Breakdown) ---

	}
	buff.WriteFloat64(target.CPUCost)     // write float64
	buff.WriteFloat64(target.GPUCost)     // write float64
	buff.WriteFloat64(target.RAMCost)     // write float64
	buff.WriteFloat64(target.Discount)    // write float64
	buff.WriteFloat64(target.Preemptible) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Node type
func (target *Node) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Node. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		e := make(map[string]string)
		f := buff.ReadInt() // map len
		for i := 0; i < f; i++ {
			var k string
			g := buff.ReadString() // read string
			k = g

			var v string
			h := buff.ReadString() // read string
			v = h

			e[k] = v
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	l := &time.Time{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.start = *l
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	o := &time.Time{}
	p := buff.ReadInt()    // byte array length
	q := buff.ReadBytes(p) // byte array
	errC := o.UnmarshalBinary(q)
	if errC != nil {
		return errC
	}
	target.end = *o
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errD := r.UnmarshalBinary(t)
	if errD != nil {
		return errD
	}
	target.window = *r
	// --- [end][read][struct](Window) ---

	u := buff.ReadFloat64() // read float64
	target.adjustment = u

	w := buff.ReadString() // read string
	target.NodeType = w

	x := buff.ReadFloat64() // read float64
	target.CPUCoreHours = x

	y := buff.ReadFloat64() // read float64
	target.RAMByteHours = y

	if buff.ReadUInt8() == uint8(0) {
		target.CPUBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		z := &Breakdown{}
		aa := buff.ReadInt()     // byte array length
		bb := buff.ReadBytes(aa) // byte array
		errE := z.UnmarshalBinary(bb)
		if errE != nil {
			return errE
		}
		target.CPUBreakdown = z
		// --- [end][read][struct](Breakdown) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.RAMBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		cc := &Breakdown{}
		dd := buff.ReadInt()     // byte array length
		ee := buff.ReadBytes(dd) // byte array
		errF := cc.UnmarshalBinary(ee)
		if errF != nil {
			return errF
		}
		target.RAMBreakdown = cc
		// --- [end][read][struct](Breakdown) ---

	}
	ff := buff.ReadFloat64() // read float64
	target.CPUCost = ff

	gg := buff.ReadFloat64() // read float64
	target.GPUCost = gg

	hh := buff.ReadFloat64() // read float64
	target.RAMCost = hh

	ll := buff.ReadFloat64() // read float64
	target.Discount = ll

	mm := buff.ReadFloat64() // read float64
	target.Preemptible = mm

	return nil
}

//--------------------------------------------------------------------------
//  SharedAsset
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this SharedAsset instance
// into a byte array
func (target *SharedAsset) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for k, v := range map[string]string(target.labels) {
			buff.WriteString(k) // write string
			buff.WriteString(v) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][struct](Window) ---
	b, errB := target.window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the SharedAsset type
func (target *SharedAsset) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling SharedAsset. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		e := make(map[string]string)
		f := buff.ReadInt() // map len
		for i := 0; i < f; i++ {
			var k string
			g := buff.ReadString() // read string
			k = g

			var v string
			h := buff.ReadString() // read string
			v = h

			e[k] = v
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][struct](Window) ---
	l := &Window{}
	m := buff.ReadInt()    // byte array length
	n := buff.ReadBytes(m) // byte array
	errB := l.UnmarshalBinary(n)
	if errB != nil {
		return errB
	}
	target.window = *l
	// --- [end][read][struct](Window) ---

	o := buff.ReadFloat64() // read float64
	target.Cost = o

	return nil
}

//--------------------------------------------------------------------------
//  Window
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Window instance
// into a byte array
func (target *Window) MarshalBinary() (data []byte, err error) {
	buff := util.NewBuffer()
	buff.WriteUInt8(3) // version

	if target.start == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		a, errA := target.start.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][reference](time.Time) ---

	}
	if target.end == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		b, errB := target.end.MarshalBinary()
		if errB != nil {
			return nil, errB
		}
		buff.WriteInt(len(b))
		buff.WriteBytes(b)
		// --- [end][write][reference](time.Time) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinary(data []byte) error {
	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != 3 {
		return fmt.Errorf("Invalid Version Unmarshaling Window. Expected 3, got %d", version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.start = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.start = a
		// --- [end][read][reference](time.Time) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.end = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		d := &time.Time{}
		e := buff.ReadInt()    // byte array length
		f := buff.ReadBytes(e) // byte array
		errB := d.UnmarshalBinary(f)
		if errB != nil {
			return errB
		}
		target.end = d
		// --- [end][read][reference](time.Time) ---

	}
	return nil
}
