////////////////////////////////////////////////////////////////////////////////
//
//                             DO NOT MODIFY
//
//                          ┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻
//
//
//            This source file was automatically generated by bingen.
//
////////////////////////////////////////////////////////////////////////////////

package kubecost

import (
	"fmt"
	util "github.com/opencost/opencost/pkg/util"
	"reflect"
	"strings"
	"sync"
	"time"
)

const (
	// GeneratorPackageName is the package the generator is targetting
	GeneratorPackageName string = "kubecost"
)

// BinaryTags represent the formatting tag used for specific optimization features
const (
	// BinaryTagStringTable is written and/or read prior to the existence of a string
	// table (where each index is encoded as a string entry in the resource
	BinaryTagStringTable string = "BGST"
)

const (
	// AssetsCodecVersion is used for any resources listed in the Assets version set
	AssetsCodecVersion uint8 = 18

	// AllocationCodecVersion is used for any resources listed in the Allocation version set
	AllocationCodecVersion uint8 = 16

	// AuditCodecVersion is used for any resources listed in the Audit version set
	AuditCodecVersion uint8 = 1

	// CloudCostAggregateCodecVersion is used for any resources listed in the CloudCostAggregate version set
	CloudCostAggregateCodecVersion uint8 = 1

	// CloudCostItemCodecVersion is used for any resources listed in the CloudCostItem version set
	CloudCostItemCodecVersion uint8 = 1

	// DefaultCodecVersion is used for any resources listed in the Default version set
	DefaultCodecVersion uint8 = 17
)

//--------------------------------------------------------------------------
//  Type Map
//--------------------------------------------------------------------------

// Generated type map for resolving interface implementations to
// to concrete types
var typeMap map[string]reflect.Type = map[string]reflect.Type{
	"AggAudit":                      reflect.TypeOf((*AggAudit)(nil)).Elem(),
	"Allocation":                    reflect.TypeOf((*Allocation)(nil)).Elem(),
	"AllocationProperties":          reflect.TypeOf((*AllocationProperties)(nil)).Elem(),
	"AllocationReconciliationAudit": reflect.TypeOf((*AllocationReconciliationAudit)(nil)).Elem(),
	"AllocationSet":                 reflect.TypeOf((*AllocationSet)(nil)).Elem(),
	"AllocationSetRange":            reflect.TypeOf((*AllocationSetRange)(nil)).Elem(),
	"Any":                           reflect.TypeOf((*Any)(nil)).Elem(),
	"AssetProperties":               reflect.TypeOf((*AssetProperties)(nil)).Elem(),
	"AssetReconciliationAudit":      reflect.TypeOf((*AssetReconciliationAudit)(nil)).Elem(),
	"AssetSet":                      reflect.TypeOf((*AssetSet)(nil)).Elem(),
	"AssetSetRange":                 reflect.TypeOf((*AssetSetRange)(nil)).Elem(),
	"AuditFloatResult":              reflect.TypeOf((*AuditFloatResult)(nil)).Elem(),
	"AuditMissingValue":             reflect.TypeOf((*AuditMissingValue)(nil)).Elem(),
	"AuditSet":                      reflect.TypeOf((*AuditSet)(nil)).Elem(),
	"AuditSetRange":                 reflect.TypeOf((*AuditSetRange)(nil)).Elem(),
	"Breakdown":                     reflect.TypeOf((*Breakdown)(nil)).Elem(),
	"Cloud":                         reflect.TypeOf((*Cloud)(nil)).Elem(),
	"CloudCostAggregate":            reflect.TypeOf((*CloudCostAggregate)(nil)).Elem(),
	"CloudCostAggregateProperties":  reflect.TypeOf((*CloudCostAggregateProperties)(nil)).Elem(),
	"CloudCostAggregateSet":         reflect.TypeOf((*CloudCostAggregateSet)(nil)).Elem(),
	"CloudCostAggregateSetRange":    reflect.TypeOf((*CloudCostAggregateSetRange)(nil)).Elem(),
	"CloudCostItem":                 reflect.TypeOf((*CloudCostItem)(nil)).Elem(),
	"CloudCostItemProperties":       reflect.TypeOf((*CloudCostItemProperties)(nil)).Elem(),
	"CloudCostItemSet":              reflect.TypeOf((*CloudCostItemSet)(nil)).Elem(),
	"CloudCostItemSetRange":         reflect.TypeOf((*CloudCostItemSetRange)(nil)).Elem(),
	"ClusterManagement":             reflect.TypeOf((*ClusterManagement)(nil)).Elem(),
	"Coverage":                      reflect.TypeOf((*Coverage)(nil)).Elem(),
	"CoverageSet":                   reflect.TypeOf((*CoverageSet)(nil)).Elem(),
	"Disk":                          reflect.TypeOf((*Disk)(nil)).Elem(),
	"EqualityAudit":                 reflect.TypeOf((*EqualityAudit)(nil)).Elem(),
	"LoadBalancer":                  reflect.TypeOf((*LoadBalancer)(nil)).Elem(),
	"Network":                       reflect.TypeOf((*Network)(nil)).Elem(),
	"Node":                          reflect.TypeOf((*Node)(nil)).Elem(),
	"PVAllocation":                  reflect.TypeOf((*PVAllocation)(nil)).Elem(),
	"PVKey":                         reflect.TypeOf((*PVKey)(nil)).Elem(),
	"RawAllocationOnlyData":         reflect.TypeOf((*RawAllocationOnlyData)(nil)).Elem(),
	"SharedAsset":                   reflect.TypeOf((*SharedAsset)(nil)).Elem(),
	"TotalAudit":                    reflect.TypeOf((*TotalAudit)(nil)).Elem(),
	"Window":                        reflect.TypeOf((*Window)(nil)).Elem(),
}

//--------------------------------------------------------------------------
//  Type Helpers
//--------------------------------------------------------------------------

// isBinaryTag returns true when the first bytes in the provided binary matches the tag
func isBinaryTag(data []byte, tag string) bool {
	return string(data[:len(tag)]) == tag
}

// appendBytes combines a and b into a new byte array
func appendBytes(a []byte, b []byte) []byte {
	al := len(a)
	bl := len(b)
	tl := al + bl

	// allocate a new byte array for the combined
	// use native copy for speedy byte copying
	result := make([]byte, tl, tl)
	copy(result, a)
	copy(result[al:], b)

	return result
}

// typeToString determines the basic properties of the type, the qualifier, package path, and
// type name, and returns the qualified type
func typeToString(f interface{}) string {
	qual := ""
	t := reflect.TypeOf(f)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
		qual = "*"
	}

	return fmt.Sprintf("%s%s.%s", qual, t.PkgPath(), t.Name())
}

// resolveType uses the name of a type and returns the package, base type name, and whether
// or not it's a pointer.
func resolveType(t string) (pkg string, name string, isPtr bool) {
	isPtr = t[:1] == "*"
	if isPtr {
		t = t[1:]
	}

	slashIndex := strings.LastIndex(t, "/")
	if slashIndex >= 0 {
		t = t[slashIndex+1:]
	}
	parts := strings.Split(t, ".")
	if parts[0] == GeneratorPackageName {
		parts[0] = ""
	}

	pkg = parts[0]
	name = parts[1]
	return
}

//--------------------------------------------------------------------------
//  StringTable
//--------------------------------------------------------------------------

// StringTable maps strings to specific indices for encoding
type StringTable struct {
	l       *sync.Mutex
	indices map[string]int
	next    int
}

// NewStringTable Creates a new StringTable instance with provided contents
func NewStringTable(contents ...string) *StringTable {
	st := &StringTable{
		l:       new(sync.Mutex),
		indices: make(map[string]int),
		next:    len(contents),
	}

	for i, entry := range contents {
		st.indices[entry] = i
	}

	return st
}

// AddOrGet atomically retrieves a string entry's index if it exist. Otherwise, it will
// add the entry and return the index.
func (st *StringTable) AddOrGet(s string) int {
	st.l.Lock()
	defer st.l.Unlock()

	if ind, ok := st.indices[s]; ok {
		return ind
	}

	current := st.next
	st.next++

	st.indices[s] = current
	return current
}

// ToSlice Converts the contents to a string array for encoding.
func (st *StringTable) ToSlice() []string {
	st.l.Lock()
	defer st.l.Unlock()

	if st.next == 0 {
		return []string{}
	}

	sl := make([]string, st.next, st.next)
	for s, i := range st.indices {
		sl[i] = s
	}
	return sl
}

// ToBytes Converts the contents to a binary encoded representation
func (st *StringTable) ToBytes() []byte {
	buff := util.NewBuffer()
	buff.WriteBytes([]byte(BinaryTagStringTable)) // bingen table header

	strs := st.ToSlice()

	buff.WriteInt(len(strs)) // table length
	for _, s := range strs {
		buff.WriteString(s)
	}

	return buff.Bytes()
}

//--------------------------------------------------------------------------
//  Codec Context
//--------------------------------------------------------------------------

// EncodingContext is a context object passed to the encoders to ensure reuse of buffer
// and table data
type EncodingContext struct {
	Buffer *util.Buffer
	Table  *StringTable
}

// IsStringTable returns true if the table is available
func (ec *EncodingContext) IsStringTable() bool {
	return ec.Table != nil
}

// DecodingContext is a context object passed to the decoders to ensure parent objects
// reuse as much data as possible
type DecodingContext struct {
	Buffer *util.Buffer
	Table  []string
}

// IsStringTable returns true if the table is available
func (dc *DecodingContext) IsStringTable() bool {
	return len(dc.Table) > 0
}

//--------------------------------------------------------------------------
//  Binary Codec
//--------------------------------------------------------------------------

// BinEncoder is an encoding interface which defines a context based marshal contract.
type BinEncoder interface {
	MarshalBinaryWithContext(*EncodingContext) error
}

// BinDecoder is a decoding interface which defines a context based unmarshal contract.
type BinDecoder interface {
	UnmarshalBinaryWithContext(*DecodingContext) error
}

//--------------------------------------------------------------------------
//  AggAudit
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AggAudit instance
// into a byte array
func (target *AggAudit) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AggAudit instance
// into a byte array leveraging a predefined context.
func (target *AggAudit) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	// --- [begin][write][alias](AuditStatus) ---
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(string(target.Status))
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(string(target.Status)) // write string
	}
	// --- [end][write][alias](AuditStatus) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Description)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Description) // write string
	}
	// --- [begin][write][reference](time.Time) ---
	c, errA := target.LastRun.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	if target.Results == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]map[string]*AuditFloatResult) ---
		buff.WriteInt(len(target.Results)) // map length
		for v, z := range target.Results {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(v)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][map](map[string]*AuditFloatResult) ---
				buff.WriteInt(len(z)) // map length
				for vv, zz := range z {
					if ctx.IsStringTable() {
						e := ctx.Table.AddOrGet(vv)
						buff.WriteInt(e) // write table index
					} else {
						buff.WriteString(vv) // write string
					}
					if zz == nil {
						buff.WriteUInt8(uint8(0)) // write nil byte
					} else {
						buff.WriteUInt8(uint8(1)) // write non-nil byte

						// --- [begin][write][struct](AuditFloatResult) ---
						buff.WriteInt(0) // [compatibility, unused]
						errB := zz.MarshalBinaryWithContext(ctx)
						if errB != nil {
							return errB
						}
						// --- [end][write][struct](AuditFloatResult) ---

					}
				}
				// --- [end][write][map](map[string]*AuditFloatResult) ---

			}
		}
		// --- [end][write][map](map[string]map[string]*AuditFloatResult) ---

	}
	if target.MissingValues == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AuditMissingValue) ---
		buff.WriteInt(len(target.MissingValues)) // array length
		for i := 0; i < len(target.MissingValues); i++ {
			if target.MissingValues[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditMissingValue) ---
				buff.WriteInt(0) // [compatibility, unused]
				errC := target.MissingValues[i].MarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				// --- [end][write][struct](AuditMissingValue) ---

			}
		}
		// --- [end][write][slice]([]*AuditMissingValue) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AggAudit type
func (target *AggAudit) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AggAudit type
func (target *AggAudit) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AggAudit. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	// --- [begin][read][alias](AuditStatus) ---
	var a string
	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	a = b

	target.Status = AuditStatus(a)
	// --- [end][read][alias](AuditStatus) ---

	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.Description = e

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	k := buff.ReadInt()    // byte array length
	l := buff.ReadBytes(k) // byte array
	errA := h.UnmarshalBinary(l)
	if errA != nil {
		return errA
	}
	target.LastRun = *h
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Results = nil
	} else {
		// --- [begin][read][map](map[string]map[string]*AuditFloatResult) ---
		n := buff.ReadInt() // map len
		m := make(map[string]map[string]*AuditFloatResult, n)
		for i := 0; i < n; i++ {
			var v string
			var p string
			if ctx.IsStringTable() {
				q := buff.ReadInt() // read string index
				p = ctx.Table[q]
			} else {
				p = buff.ReadString() // read string
			}
			o := p
			v = o

			var z map[string]*AuditFloatResult
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][map](map[string]*AuditFloatResult) ---
				s := buff.ReadInt() // map len
				r := make(map[string]*AuditFloatResult, s)
				for j := 0; j < s; j++ {
					var vv string
					var u string
					if ctx.IsStringTable() {
						w := buff.ReadInt() // read string index
						u = ctx.Table[w]
					} else {
						u = buff.ReadString() // read string
					}
					t := u
					vv = t

					var zz *AuditFloatResult
					if buff.ReadUInt8() == uint8(0) {
						zz = nil
					} else {
						// --- [begin][read][struct](AuditFloatResult) ---
						x := &AuditFloatResult{}
						buff.ReadInt() // [compatibility, unused]
						errB := x.UnmarshalBinaryWithContext(ctx)
						if errB != nil {
							return errB
						}
						zz = x
						// --- [end][read][struct](AuditFloatResult) ---

					}
					r[vv] = zz
				}
				z = r
				// --- [end][read][map](map[string]*AuditFloatResult) ---

			}
			m[v] = z
		}
		target.Results = m
		// --- [end][read][map](map[string]map[string]*AuditFloatResult) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.MissingValues = nil
	} else {
		// --- [begin][read][slice]([]*AuditMissingValue) ---
		aa := buff.ReadInt() // array len
		y := make([]*AuditMissingValue, aa)
		for ii := 0; ii < aa; ii++ {
			var bb *AuditMissingValue
			if buff.ReadUInt8() == uint8(0) {
				bb = nil
			} else {
				// --- [begin][read][struct](AuditMissingValue) ---
				cc := &AuditMissingValue{}
				buff.ReadInt() // [compatibility, unused]
				errC := cc.UnmarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				bb = cc
				// --- [end][read][struct](AuditMissingValue) ---

			}
			y[ii] = bb
		}
		target.MissingValues = y
		// --- [end][read][slice]([]*AuditMissingValue) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  Allocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Allocation instance
// into a byte array
func (target *Allocation) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Allocation instance
// into a byte array leveraging a predefined context.
func (target *Allocation) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AllocationProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AllocationProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	// --- [begin][write][reference](time.Time) ---
	b, errC := target.Start.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errD := target.End.MarshalBinary()
	if errD != nil {
		return errD
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	buff.WriteFloat64(target.CPUCoreHours)               // write float64
	buff.WriteFloat64(target.CPUCoreRequestAverage)      // write float64
	buff.WriteFloat64(target.CPUCoreUsageAverage)        // write float64
	buff.WriteFloat64(target.CPUCost)                    // write float64
	buff.WriteFloat64(target.CPUCostAdjustment)          // write float64
	buff.WriteFloat64(target.GPUHours)                   // write float64
	buff.WriteFloat64(target.GPUCost)                    // write float64
	buff.WriteFloat64(target.GPUCostAdjustment)          // write float64
	buff.WriteFloat64(target.NetworkTransferBytes)       // write float64
	buff.WriteFloat64(target.NetworkReceiveBytes)        // write float64
	buff.WriteFloat64(target.NetworkCost)                // write float64
	buff.WriteFloat64(target.NetworkCrossZoneCost)       // write float64
	buff.WriteFloat64(target.NetworkCrossRegionCost)     // write float64
	buff.WriteFloat64(target.NetworkInternetCost)        // write float64
	buff.WriteFloat64(target.NetworkCostAdjustment)      // write float64
	buff.WriteFloat64(target.LoadBalancerCost)           // write float64
	buff.WriteFloat64(target.LoadBalancerCostAdjustment) // write float64
	// --- [begin][write][alias](PVAllocations) ---
	if map[PVKey]*PVAllocation(target.PVs) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[PVKey]*PVAllocation) ---
		buff.WriteInt(len(map[PVKey]*PVAllocation(target.PVs))) // map length
		for v, z := range map[PVKey]*PVAllocation(target.PVs) {
			// --- [begin][write][struct](PVKey) ---
			buff.WriteInt(0) // [compatibility, unused]
			errE := v.MarshalBinaryWithContext(ctx)
			if errE != nil {
				return errE
			}
			// --- [end][write][struct](PVKey) ---

			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](PVAllocation) ---
				buff.WriteInt(0) // [compatibility, unused]
				errF := z.MarshalBinaryWithContext(ctx)
				if errF != nil {
					return errF
				}
				// --- [end][write][struct](PVAllocation) ---

			}
		}
		// --- [end][write][map](map[PVKey]*PVAllocation) ---

	}
	// --- [end][write][alias](PVAllocations) ---

	buff.WriteFloat64(target.PVCostAdjustment)       // write float64
	buff.WriteFloat64(target.RAMByteHours)           // write float64
	buff.WriteFloat64(target.RAMBytesRequestAverage) // write float64
	buff.WriteFloat64(target.RAMBytesUsageAverage)   // write float64
	buff.WriteFloat64(target.RAMCost)                // write float64
	buff.WriteFloat64(target.RAMCostAdjustment)      // write float64
	buff.WriteFloat64(target.SharedCost)             // write float64
	buff.WriteFloat64(target.ExternalCost)           // write float64
	if target.RawAllocationOnly == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](RawAllocationOnlyData) ---
		buff.WriteInt(0) // [compatibility, unused]
		errG := target.RawAllocationOnly.MarshalBinaryWithContext(ctx)
		if errG != nil {
			return errG
		}
		// --- [end][write][struct](RawAllocationOnlyData) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Allocation type
func (target *Allocation) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Allocation type
func (target *Allocation) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Allocation. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Name = a

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AllocationProperties) ---
		d := &AllocationProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := d.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = d
		// --- [end][read][struct](AllocationProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	e := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := e.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *e
	// --- [end][read][struct](Window) ---

	// --- [begin][read][reference](time.Time) ---
	f := &time.Time{}
	g := buff.ReadInt()    // byte array length
	h := buff.ReadBytes(g) // byte array
	errC := f.UnmarshalBinary(h)
	if errC != nil {
		return errC
	}
	target.Start = *f
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errD := k.UnmarshalBinary(m)
	if errD != nil {
		return errD
	}
	target.End = *k
	// --- [end][read][reference](time.Time) ---

	n := buff.ReadFloat64() // read float64
	target.CPUCoreHours = n

	o := buff.ReadFloat64() // read float64
	target.CPUCoreRequestAverage = o

	p := buff.ReadFloat64() // read float64
	target.CPUCoreUsageAverage = p

	q := buff.ReadFloat64() // read float64
	target.CPUCost = q

	r := buff.ReadFloat64() // read float64
	target.CPUCostAdjustment = r

	s := buff.ReadFloat64() // read float64
	target.GPUHours = s

	t := buff.ReadFloat64() // read float64
	target.GPUCost = t

	u := buff.ReadFloat64() // read float64
	target.GPUCostAdjustment = u

	w := buff.ReadFloat64() // read float64
	target.NetworkTransferBytes = w

	x := buff.ReadFloat64() // read float64
	target.NetworkReceiveBytes = x

	y := buff.ReadFloat64() // read float64
	target.NetworkCost = y

	// field version check
	if uint8(16) <= version {
		aa := buff.ReadFloat64() // read float64
		target.NetworkCrossZoneCost = aa

	} else {
		target.NetworkCrossZoneCost = float64(0) // default
	}

	// field version check
	if uint8(16) <= version {
		bb := buff.ReadFloat64() // read float64
		target.NetworkCrossRegionCost = bb

	} else {
		target.NetworkCrossRegionCost = float64(0) // default
	}

	// field version check
	if uint8(16) <= version {
		cc := buff.ReadFloat64() // read float64
		target.NetworkInternetCost = cc

	} else {
		target.NetworkInternetCost = float64(0) // default
	}

	dd := buff.ReadFloat64() // read float64
	target.NetworkCostAdjustment = dd

	ee := buff.ReadFloat64() // read float64
	target.LoadBalancerCost = ee

	ff := buff.ReadFloat64() // read float64
	target.LoadBalancerCostAdjustment = ff

	// --- [begin][read][alias](PVAllocations) ---
	var gg map[PVKey]*PVAllocation
	if buff.ReadUInt8() == uint8(0) {
		gg = nil
	} else {
		// --- [begin][read][map](map[PVKey]*PVAllocation) ---
		kk := buff.ReadInt() // map len
		hh := make(map[PVKey]*PVAllocation, kk)
		for i := 0; i < kk; i++ {
			// --- [begin][read][struct](PVKey) ---
			ll := &PVKey{}
			buff.ReadInt() // [compatibility, unused]
			errE := ll.UnmarshalBinaryWithContext(ctx)
			if errE != nil {
				return errE
			}
			v := *ll
			// --- [end][read][struct](PVKey) ---

			var z *PVAllocation
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](PVAllocation) ---
				mm := &PVAllocation{}
				buff.ReadInt() // [compatibility, unused]
				errF := mm.UnmarshalBinaryWithContext(ctx)
				if errF != nil {
					return errF
				}
				z = mm
				// --- [end][read][struct](PVAllocation) ---

			}
			hh[v] = z
		}
		gg = hh
		// --- [end][read][map](map[PVKey]*PVAllocation) ---

	}
	target.PVs = PVAllocations(gg)
	// --- [end][read][alias](PVAllocations) ---

	nn := buff.ReadFloat64() // read float64
	target.PVCostAdjustment = nn

	oo := buff.ReadFloat64() // read float64
	target.RAMByteHours = oo

	pp := buff.ReadFloat64() // read float64
	target.RAMBytesRequestAverage = pp

	qq := buff.ReadFloat64() // read float64
	target.RAMBytesUsageAverage = qq

	rr := buff.ReadFloat64() // read float64
	target.RAMCost = rr

	ss := buff.ReadFloat64() // read float64
	target.RAMCostAdjustment = ss

	tt := buff.ReadFloat64() // read float64
	target.SharedCost = tt

	uu := buff.ReadFloat64() // read float64
	target.ExternalCost = uu

	if buff.ReadUInt8() == uint8(0) {
		target.RawAllocationOnly = nil
	} else {
		// --- [begin][read][struct](RawAllocationOnlyData) ---
		ww := &RawAllocationOnlyData{}
		buff.ReadInt() // [compatibility, unused]
		errG := ww.UnmarshalBinaryWithContext(ctx)
		if errG != nil {
			return errG
		}
		target.RawAllocationOnly = ww
		// --- [end][read][struct](RawAllocationOnlyData) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AllocationProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationProperties instance
// into a byte array
func (target *AllocationProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationProperties instance
// into a byte array leveraging a predefined context.
func (target *AllocationProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Cluster)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Cluster) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Node)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Node) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Container)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Container) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.Controller)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.Controller) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.ControllerKind)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.ControllerKind) // write string
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.Namespace)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.Namespace) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.Pod)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.Pod) // write string
	}
	if target.Services == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Services)) // array length
		for i := 0; i < len(target.Services); i++ {
			if ctx.IsStringTable() {
				h := ctx.Table.AddOrGet(target.Services[i])
				buff.WriteInt(h) // write table index
			} else {
				buff.WriteString(target.Services[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if ctx.IsStringTable() {
		k := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(k) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	// --- [begin][write][alias](AllocationLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				l := ctx.Table.AddOrGet(v)
				buff.WriteInt(l) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				m := ctx.Table.AddOrGet(z)
				buff.WriteInt(m) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationLabels) ---

	// --- [begin][write][alias](AllocationAnnotations) ---
	if map[string]string(target.Annotations) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Annotations))) // map length
		for vv, zz := range map[string]string(target.Annotations) {
			if ctx.IsStringTable() {
				n := ctx.Table.AddOrGet(vv)
				buff.WriteInt(n) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			if ctx.IsStringTable() {
				o := ctx.Table.AddOrGet(zz)
				buff.WriteInt(o) // write table index
			} else {
				buff.WriteString(zz) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationAnnotations) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationProperties type
func (target *AllocationProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationProperties type
func (target *AllocationProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationProperties. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Cluster = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Node = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.Container = g

	var m string
	if ctx.IsStringTable() {
		n := buff.ReadInt() // read string index
		m = ctx.Table[n]
	} else {
		m = buff.ReadString() // read string
	}
	l := m
	target.Controller = l

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.ControllerKind = o

	var s string
	if ctx.IsStringTable() {
		t := buff.ReadInt() // read string index
		s = ctx.Table[t]
	} else {
		s = buff.ReadString() // read string
	}
	r := s
	target.Namespace = r

	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.Pod = u

	if buff.ReadUInt8() == uint8(0) {
		target.Services = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		aa := buff.ReadInt() // array len
		y := make([]string, aa)
		for i := 0; i < aa; i++ {
			var bb string
			var dd string
			if ctx.IsStringTable() {
				ee := buff.ReadInt() // read string index
				dd = ctx.Table[ee]
			} else {
				dd = buff.ReadString() // read string
			}
			cc := dd
			bb = cc

			y[i] = bb
		}
		target.Services = y
		// --- [end][read][slice]([]string) ---

	}
	var gg string
	if ctx.IsStringTable() {
		hh := buff.ReadInt() // read string index
		gg = ctx.Table[hh]
	} else {
		gg = buff.ReadString() // read string
	}
	ff := gg
	target.ProviderID = ff

	// --- [begin][read][alias](AllocationLabels) ---
	var kk map[string]string
	if buff.ReadUInt8() == uint8(0) {
		kk = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		mm := buff.ReadInt() // map len
		ll := make(map[string]string, mm)
		for j := 0; j < mm; j++ {
			var v string
			var oo string
			if ctx.IsStringTable() {
				pp := buff.ReadInt() // read string index
				oo = ctx.Table[pp]
			} else {
				oo = buff.ReadString() // read string
			}
			nn := oo
			v = nn

			var z string
			var rr string
			if ctx.IsStringTable() {
				ss := buff.ReadInt() // read string index
				rr = ctx.Table[ss]
			} else {
				rr = buff.ReadString() // read string
			}
			qq := rr
			z = qq

			ll[v] = z
		}
		kk = ll
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AllocationLabels(kk)
	// --- [end][read][alias](AllocationLabels) ---

	// --- [begin][read][alias](AllocationAnnotations) ---
	var tt map[string]string
	if buff.ReadUInt8() == uint8(0) {
		tt = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		ww := buff.ReadInt() // map len
		uu := make(map[string]string, ww)
		for ii := 0; ii < ww; ii++ {
			var vv string
			var yy string
			if ctx.IsStringTable() {
				aaa := buff.ReadInt() // read string index
				yy = ctx.Table[aaa]
			} else {
				yy = buff.ReadString() // read string
			}
			xx := yy
			vv = xx

			var zz string
			var ccc string
			if ctx.IsStringTable() {
				ddd := buff.ReadInt() // read string index
				ccc = ctx.Table[ddd]
			} else {
				ccc = buff.ReadString() // read string
			}
			bbb := ccc
			zz = bbb

			uu[vv] = zz
		}
		tt = uu
		// --- [end][read][map](map[string]string) ---

	}
	target.Annotations = AllocationAnnotations(tt)
	// --- [end][read][alias](AllocationAnnotations) ---

	return nil
}

//--------------------------------------------------------------------------
//  AllocationReconciliationAudit
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationReconciliationAudit instance
// into a byte array
func (target *AllocationReconciliationAudit) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationReconciliationAudit instance
// into a byte array leveraging a predefined context.
func (target *AllocationReconciliationAudit) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	// --- [begin][write][alias](AuditStatus) ---
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(string(target.Status))
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(string(target.Status)) // write string
	}
	// --- [end][write][alias](AuditStatus) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Description)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Description) // write string
	}
	// --- [begin][write][reference](time.Time) ---
	c, errA := target.LastRun.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	if target.Resources == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]map[string]*AuditFloatResult) ---
		buff.WriteInt(len(target.Resources)) // map length
		for v, z := range target.Resources {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(v)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][map](map[string]*AuditFloatResult) ---
				buff.WriteInt(len(z)) // map length
				for vv, zz := range z {
					if ctx.IsStringTable() {
						e := ctx.Table.AddOrGet(vv)
						buff.WriteInt(e) // write table index
					} else {
						buff.WriteString(vv) // write string
					}
					if zz == nil {
						buff.WriteUInt8(uint8(0)) // write nil byte
					} else {
						buff.WriteUInt8(uint8(1)) // write non-nil byte

						// --- [begin][write][struct](AuditFloatResult) ---
						buff.WriteInt(0) // [compatibility, unused]
						errB := zz.MarshalBinaryWithContext(ctx)
						if errB != nil {
							return errB
						}
						// --- [end][write][struct](AuditFloatResult) ---

					}
				}
				// --- [end][write][map](map[string]*AuditFloatResult) ---

			}
		}
		// --- [end][write][map](map[string]map[string]*AuditFloatResult) ---

	}
	if target.MissingValues == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AuditMissingValue) ---
		buff.WriteInt(len(target.MissingValues)) // array length
		for i := 0; i < len(target.MissingValues); i++ {
			if target.MissingValues[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditMissingValue) ---
				buff.WriteInt(0) // [compatibility, unused]
				errC := target.MissingValues[i].MarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				// --- [end][write][struct](AuditMissingValue) ---

			}
		}
		// --- [end][write][slice]([]*AuditMissingValue) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationReconciliationAudit type
func (target *AllocationReconciliationAudit) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationReconciliationAudit type
func (target *AllocationReconciliationAudit) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationReconciliationAudit. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	// --- [begin][read][alias](AuditStatus) ---
	var a string
	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	a = b

	target.Status = AuditStatus(a)
	// --- [end][read][alias](AuditStatus) ---

	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.Description = e

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	k := buff.ReadInt()    // byte array length
	l := buff.ReadBytes(k) // byte array
	errA := h.UnmarshalBinary(l)
	if errA != nil {
		return errA
	}
	target.LastRun = *h
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Resources = nil
	} else {
		// --- [begin][read][map](map[string]map[string]*AuditFloatResult) ---
		n := buff.ReadInt() // map len
		m := make(map[string]map[string]*AuditFloatResult, n)
		for i := 0; i < n; i++ {
			var v string
			var p string
			if ctx.IsStringTable() {
				q := buff.ReadInt() // read string index
				p = ctx.Table[q]
			} else {
				p = buff.ReadString() // read string
			}
			o := p
			v = o

			var z map[string]*AuditFloatResult
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][map](map[string]*AuditFloatResult) ---
				s := buff.ReadInt() // map len
				r := make(map[string]*AuditFloatResult, s)
				for j := 0; j < s; j++ {
					var vv string
					var u string
					if ctx.IsStringTable() {
						w := buff.ReadInt() // read string index
						u = ctx.Table[w]
					} else {
						u = buff.ReadString() // read string
					}
					t := u
					vv = t

					var zz *AuditFloatResult
					if buff.ReadUInt8() == uint8(0) {
						zz = nil
					} else {
						// --- [begin][read][struct](AuditFloatResult) ---
						x := &AuditFloatResult{}
						buff.ReadInt() // [compatibility, unused]
						errB := x.UnmarshalBinaryWithContext(ctx)
						if errB != nil {
							return errB
						}
						zz = x
						// --- [end][read][struct](AuditFloatResult) ---

					}
					r[vv] = zz
				}
				z = r
				// --- [end][read][map](map[string]*AuditFloatResult) ---

			}
			m[v] = z
		}
		target.Resources = m
		// --- [end][read][map](map[string]map[string]*AuditFloatResult) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.MissingValues = nil
	} else {
		// --- [begin][read][slice]([]*AuditMissingValue) ---
		aa := buff.ReadInt() // array len
		y := make([]*AuditMissingValue, aa)
		for ii := 0; ii < aa; ii++ {
			var bb *AuditMissingValue
			if buff.ReadUInt8() == uint8(0) {
				bb = nil
			} else {
				// --- [begin][read][struct](AuditMissingValue) ---
				cc := &AuditMissingValue{}
				buff.ReadInt() // [compatibility, unused]
				errC := cc.UnmarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				bb = cc
				// --- [end][read][struct](AuditMissingValue) ---

			}
			y[ii] = bb
		}
		target.MissingValues = y
		// --- [end][read][slice]([]*AuditMissingValue) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AllocationSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSet instance
// into a byte array
func (target *AllocationSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationSet instance
// into a byte array leveraging a predefined context.
func (target *AllocationSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if target.Allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Allocation) ---
		buff.WriteInt(len(target.Allocations)) // map length
		for v, z := range target.Allocations {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Allocation) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := z.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](Allocation) ---

			}
		}
		// --- [end][write][map](map[string]*Allocation) ---

	}
	if target.ExternalKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.ExternalKeys)) // map length
		for vv, zz := range target.ExternalKeys {
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(vv)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			buff.WriteBool(zz) // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	if target.IdleKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.IdleKeys)) // map length
		for vvv, zzz := range target.IdleKeys {
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(vvv)
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(vvv) // write string
			}
			buff.WriteBool(zzz) // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.FromSource)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.FromSource) // write string
	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for i := 0; i < len(target.Warnings); i++ {
			if ctx.IsStringTable() {
				e := ctx.Table.AddOrGet(target.Warnings[i])
				buff.WriteInt(e) // write table index
			} else {
				buff.WriteString(target.Warnings[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for j := 0; j < len(target.Errors); j++ {
			if ctx.IsStringTable() {
				f := ctx.Table.AddOrGet(target.Errors[j])
				buff.WriteInt(f) // write table index
			} else {
				buff.WriteString(target.Errors[j]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSet type
func (target *AllocationSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationSet type
func (target *AllocationSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSet. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Allocations = nil
	} else {
		// --- [begin][read][map](map[string]*Allocation) ---
		b := buff.ReadInt() // map len
		a := make(map[string]*Allocation, b)
		for i := 0; i < b; i++ {
			var v string
			var d string
			if ctx.IsStringTable() {
				e := buff.ReadInt() // read string index
				d = ctx.Table[e]
			} else {
				d = buff.ReadString() // read string
			}
			c := d
			v = c

			var z *Allocation
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](Allocation) ---
				f := &Allocation{}
				buff.ReadInt() // [compatibility, unused]
				errA := f.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = f
				// --- [end][read][struct](Allocation) ---

			}
			a[v] = z
		}
		target.Allocations = a
		// --- [end][read][map](map[string]*Allocation) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.ExternalKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		h := buff.ReadInt() // map len
		g := make(map[string]bool, h)
		for j := 0; j < h; j++ {
			var vv string
			var l string
			if ctx.IsStringTable() {
				m := buff.ReadInt() // read string index
				l = ctx.Table[m]
			} else {
				l = buff.ReadString() // read string
			}
			k := l
			vv = k

			var zz bool
			n := buff.ReadBool() // read bool
			zz = n

			g[vv] = zz
		}
		target.ExternalKeys = g
		// --- [end][read][map](map[string]bool) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.IdleKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		p := buff.ReadInt() // map len
		o := make(map[string]bool, p)
		for ii := 0; ii < p; ii++ {
			var vvv string
			var r string
			if ctx.IsStringTable() {
				s := buff.ReadInt() // read string index
				r = ctx.Table[s]
			} else {
				r = buff.ReadString() // read string
			}
			q := r
			vvv = q

			var zzz bool
			t := buff.ReadBool() // read bool
			zzz = t

			o[vvv] = zzz
		}
		target.IdleKeys = o
		// --- [end][read][map](map[string]bool) ---

	}
	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.FromSource = u

	// --- [begin][read][struct](Window) ---
	y := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := y.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *y
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		bb := buff.ReadInt() // array len
		aa := make([]string, bb)
		for jj := 0; jj < bb; jj++ {
			var cc string
			var ee string
			if ctx.IsStringTable() {
				ff := buff.ReadInt() // read string index
				ee = ctx.Table[ff]
			} else {
				ee = buff.ReadString() // read string
			}
			dd := ee
			cc = dd

			aa[jj] = cc
		}
		target.Warnings = aa
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		hh := buff.ReadInt() // array len
		gg := make([]string, hh)
		for iii := 0; iii < hh; iii++ {
			var kk string
			var mm string
			if ctx.IsStringTable() {
				nn := buff.ReadInt() // read string index
				mm = ctx.Table[nn]
			} else {
				mm = buff.ReadString() // read string
			}
			ll := mm
			kk = ll

			gg[iii] = kk
		}
		target.Errors = gg
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AllocationSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSetRange instance
// into a byte array
func (target *AllocationSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AllocationSetRange instance
// into a byte array leveraging a predefined context.
func (target *AllocationSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if target.Allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AllocationSet) ---
		buff.WriteInt(len(target.Allocations)) // array length
		for i := 0; i < len(target.Allocations); i++ {
			if target.Allocations[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AllocationSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.Allocations[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](AllocationSet) ---

			}
		}
		// --- [end][write][slice]([]*AllocationSet) ---

	}
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.FromStore)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.FromStore) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSetRange type
func (target *AllocationSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AllocationSetRange type
func (target *AllocationSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSetRange. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Allocations = nil
	} else {
		// --- [begin][read][slice]([]*AllocationSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AllocationSet, b)
		for i := 0; i < b; i++ {
			var c *AllocationSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AllocationSet) ---
				d := &AllocationSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AllocationSet) ---

			}
			a[i] = c
		}
		target.Allocations = a
		// --- [end][read][slice]([]*AllocationSet) ---

	}
	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.FromStore = e

	return nil
}

//--------------------------------------------------------------------------
//  Any
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Any instance
// into a byte array
func (target *Any) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Any instance
// into a byte array leveraging a predefined context.
func (target *Any) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Any type
func (target *Any) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Any type
func (target *Any) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Any. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  AssetProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetProperties instance
// into a byte array
func (target *AssetProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetProperties instance
// into a byte array leveraging a predefined context.
func (target *AssetProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Category)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Category) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Provider)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Provider) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Account)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Account) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.Project)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.Project) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.Service)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.Service) // write string
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.Cluster)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.Cluster) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	if ctx.IsStringTable() {
		h := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(h) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetProperties type
func (target *AssetProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetProperties type
func (target *AssetProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetProperties. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Category = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Provider = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.Account = g

	var m string
	if ctx.IsStringTable() {
		n := buff.ReadInt() // read string index
		m = ctx.Table[n]
	} else {
		m = buff.ReadString() // read string
	}
	l := m
	target.Project = l

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.Service = o

	var s string
	if ctx.IsStringTable() {
		t := buff.ReadInt() // read string index
		s = ctx.Table[t]
	} else {
		s = buff.ReadString() // read string
	}
	r := s
	target.Cluster = r

	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.Name = u

	var aa string
	if ctx.IsStringTable() {
		bb := buff.ReadInt() // read string index
		aa = ctx.Table[bb]
	} else {
		aa = buff.ReadString() // read string
	}
	y := aa
	target.ProviderID = y

	return nil
}

//--------------------------------------------------------------------------
//  AssetReconciliationAudit
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetReconciliationAudit instance
// into a byte array
func (target *AssetReconciliationAudit) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetReconciliationAudit instance
// into a byte array leveraging a predefined context.
func (target *AssetReconciliationAudit) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	// --- [begin][write][alias](AuditStatus) ---
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(string(target.Status))
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(string(target.Status)) // write string
	}
	// --- [end][write][alias](AuditStatus) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Description)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Description) // write string
	}
	// --- [begin][write][reference](time.Time) ---
	c, errA := target.LastRun.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	if target.Results == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]map[string]*AuditFloatResult) ---
		buff.WriteInt(len(target.Results)) // map length
		for v, z := range target.Results {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(v)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][map](map[string]*AuditFloatResult) ---
				buff.WriteInt(len(z)) // map length
				for vv, zz := range z {
					if ctx.IsStringTable() {
						e := ctx.Table.AddOrGet(vv)
						buff.WriteInt(e) // write table index
					} else {
						buff.WriteString(vv) // write string
					}
					if zz == nil {
						buff.WriteUInt8(uint8(0)) // write nil byte
					} else {
						buff.WriteUInt8(uint8(1)) // write non-nil byte

						// --- [begin][write][struct](AuditFloatResult) ---
						buff.WriteInt(0) // [compatibility, unused]
						errB := zz.MarshalBinaryWithContext(ctx)
						if errB != nil {
							return errB
						}
						// --- [end][write][struct](AuditFloatResult) ---

					}
				}
				// --- [end][write][map](map[string]*AuditFloatResult) ---

			}
		}
		// --- [end][write][map](map[string]map[string]*AuditFloatResult) ---

	}
	if target.MissingValues == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AuditMissingValue) ---
		buff.WriteInt(len(target.MissingValues)) // array length
		for i := 0; i < len(target.MissingValues); i++ {
			if target.MissingValues[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditMissingValue) ---
				buff.WriteInt(0) // [compatibility, unused]
				errC := target.MissingValues[i].MarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				// --- [end][write][struct](AuditMissingValue) ---

			}
		}
		// --- [end][write][slice]([]*AuditMissingValue) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetReconciliationAudit type
func (target *AssetReconciliationAudit) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetReconciliationAudit type
func (target *AssetReconciliationAudit) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetReconciliationAudit. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	// --- [begin][read][alias](AuditStatus) ---
	var a string
	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	a = b

	target.Status = AuditStatus(a)
	// --- [end][read][alias](AuditStatus) ---

	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.Description = e

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	k := buff.ReadInt()    // byte array length
	l := buff.ReadBytes(k) // byte array
	errA := h.UnmarshalBinary(l)
	if errA != nil {
		return errA
	}
	target.LastRun = *h
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Results = nil
	} else {
		// --- [begin][read][map](map[string]map[string]*AuditFloatResult) ---
		n := buff.ReadInt() // map len
		m := make(map[string]map[string]*AuditFloatResult, n)
		for i := 0; i < n; i++ {
			var v string
			var p string
			if ctx.IsStringTable() {
				q := buff.ReadInt() // read string index
				p = ctx.Table[q]
			} else {
				p = buff.ReadString() // read string
			}
			o := p
			v = o

			var z map[string]*AuditFloatResult
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][map](map[string]*AuditFloatResult) ---
				s := buff.ReadInt() // map len
				r := make(map[string]*AuditFloatResult, s)
				for j := 0; j < s; j++ {
					var vv string
					var u string
					if ctx.IsStringTable() {
						w := buff.ReadInt() // read string index
						u = ctx.Table[w]
					} else {
						u = buff.ReadString() // read string
					}
					t := u
					vv = t

					var zz *AuditFloatResult
					if buff.ReadUInt8() == uint8(0) {
						zz = nil
					} else {
						// --- [begin][read][struct](AuditFloatResult) ---
						x := &AuditFloatResult{}
						buff.ReadInt() // [compatibility, unused]
						errB := x.UnmarshalBinaryWithContext(ctx)
						if errB != nil {
							return errB
						}
						zz = x
						// --- [end][read][struct](AuditFloatResult) ---

					}
					r[vv] = zz
				}
				z = r
				// --- [end][read][map](map[string]*AuditFloatResult) ---

			}
			m[v] = z
		}
		target.Results = m
		// --- [end][read][map](map[string]map[string]*AuditFloatResult) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.MissingValues = nil
	} else {
		// --- [begin][read][slice]([]*AuditMissingValue) ---
		aa := buff.ReadInt() // array len
		y := make([]*AuditMissingValue, aa)
		for ii := 0; ii < aa; ii++ {
			var bb *AuditMissingValue
			if buff.ReadUInt8() == uint8(0) {
				bb = nil
			} else {
				// --- [begin][read][struct](AuditMissingValue) ---
				cc := &AuditMissingValue{}
				buff.ReadInt() // [compatibility, unused]
				errC := cc.UnmarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				bb = cc
				// --- [end][read][struct](AuditMissingValue) ---

			}
			y[ii] = bb
		}
		target.MissingValues = y
		// --- [end][read][slice]([]*AuditMissingValue) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AssetSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSet instance
// into a byte array
func (target *AssetSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetSet instance
// into a byte array leveraging a predefined context.
func (target *AssetSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// execute pre-processing func
	preProcessAssetSet(target)
	if target.AggregationKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.AggregationKeys)) // array length
		for i := 0; i < len(target.AggregationKeys); i++ {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(target.AggregationKeys[i])
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(target.AggregationKeys[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]Asset) ---
		buff.WriteInt(len(target.Assets)) // map length
		for v, z := range target.Assets {
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(v)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][interface](Asset) ---
				c := reflect.ValueOf(z).Interface()
				d, okA := c.(BinEncoder)
				if !okA {
					return fmt.Errorf("Type: %s does not implement %s.BinEncoder", typeToString(z), GeneratorPackageName)
				}
				buff.WriteString(typeToString(z))
				buff.WriteInt(0) // [compatibility, unused]
				errA := d.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][interface](Asset) ---

			}
		}
		// --- [end][write][map](map[string]Asset) ---

	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.FromSource)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.FromSource) // write string
	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for j := 0; j < len(target.Warnings); j++ {
			if ctx.IsStringTable() {
				f := ctx.Table.AddOrGet(target.Warnings[j])
				buff.WriteInt(f) // write table index
			} else {
				buff.WriteString(target.Warnings[j]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for ii := 0; ii < len(target.Errors); ii++ {
			if ctx.IsStringTable() {
				g := ctx.Table.AddOrGet(target.Errors[ii])
				buff.WriteInt(g) // write table index
			} else {
				buff.WriteString(target.Errors[ii]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSet type
func (target *AssetSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetSet type
func (target *AssetSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSet. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.AggregationKeys = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		b := buff.ReadInt() // array len
		a := make([]string, b)
		for i := 0; i < b; i++ {
			var c string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			c = d

			a[i] = c
		}
		target.AggregationKeys = a
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Assets = nil
	} else {
		// --- [begin][read][map](map[string]Asset) ---
		h := buff.ReadInt() // map len
		g := make(map[string]Asset, h)
		for j := 0; j < h; j++ {
			var v string
			var l string
			if ctx.IsStringTable() {
				m := buff.ReadInt() // read string index
				l = ctx.Table[m]
			} else {
				l = buff.ReadString() // read string
			}
			k := l
			v = k

			var z Asset
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][interface](Asset) ---
				n := buff.ReadString()
				_, o, _ := resolveType(n)
				if _, ok := typeMap[o]; !ok {
					return fmt.Errorf("Unknown Type: %s", o)
				}
				p, okA := reflect.New(typeMap[o]).Interface().(BinDecoder)
				if !okA {
					return fmt.Errorf("Type: %s does not implement %s.BinDecoder.", o, GeneratorPackageName)
				}
				buff.ReadInt() // [compatibility, unused]
				errA := p.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = p.(Asset)
				// --- [end][read][interface](Asset) ---

			}
			g[v] = z
		}
		target.Assets = g
		// --- [end][read][map](map[string]Asset) ---

	}
	var r string
	if ctx.IsStringTable() {
		s := buff.ReadInt() // read string index
		r = ctx.Table[s]
	} else {
		r = buff.ReadString() // read string
	}
	q := r
	target.FromSource = q

	// --- [begin][read][struct](Window) ---
	t := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := t.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *t
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		w := buff.ReadInt() // array len
		u := make([]string, w)
		for ii := 0; ii < w; ii++ {
			var x string
			var aa string
			if ctx.IsStringTable() {
				bb := buff.ReadInt() // read string index
				aa = ctx.Table[bb]
			} else {
				aa = buff.ReadString() // read string
			}
			y := aa
			x = y

			u[ii] = x
		}
		target.Warnings = u
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		dd := buff.ReadInt() // array len
		cc := make([]string, dd)
		for jj := 0; jj < dd; jj++ {
			var ee string
			var gg string
			if ctx.IsStringTable() {
				hh := buff.ReadInt() // read string index
				gg = ctx.Table[hh]
			} else {
				gg = buff.ReadString() // read string
			}
			ff := gg
			ee = ff

			cc[jj] = ee
		}
		target.Errors = cc
		// --- [end][read][slice]([]string) ---

	}
	// execute post-processing func
	postProcessAssetSet(target)
	return nil
}

//--------------------------------------------------------------------------
//  AssetSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSetRange instance
// into a byte array
func (target *AssetSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AssetSetRange instance
// into a byte array leveraging a predefined context.
func (target *AssetSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AssetSet) ---
		buff.WriteInt(len(target.Assets)) // array length
		for i := 0; i < len(target.Assets); i++ {
			if target.Assets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AssetSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.Assets[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](AssetSet) ---

			}
		}
		// --- [end][write][slice]([]*AssetSet) ---

	}
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.FromStore)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.FromStore) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSetRange type
func (target *AssetSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AssetSetRange type
func (target *AssetSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSetRange. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Assets = nil
	} else {
		// --- [begin][read][slice]([]*AssetSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AssetSet, b)
		for i := 0; i < b; i++ {
			var c *AssetSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AssetSet) ---
				d := &AssetSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AssetSet) ---

			}
			a[i] = c
		}
		target.Assets = a
		// --- [end][read][slice]([]*AssetSet) ---

	}
	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.FromStore = e

	return nil
}

//--------------------------------------------------------------------------
//  AuditFloatResult
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AuditFloatResult instance
// into a byte array
func (target *AuditFloatResult) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AuditFloatResult instance
// into a byte array leveraging a predefined context.
func (target *AuditFloatResult) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	buff.WriteFloat64(target.Expected) // write float64
	buff.WriteFloat64(target.Actual)   // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AuditFloatResult type
func (target *AuditFloatResult) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AuditFloatResult type
func (target *AuditFloatResult) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AuditFloatResult. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.Expected = a

	b := buff.ReadFloat64() // read float64
	target.Actual = b

	return nil
}

//--------------------------------------------------------------------------
//  AuditMissingValue
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AuditMissingValue instance
// into a byte array
func (target *AuditMissingValue) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AuditMissingValue instance
// into a byte array leveraging a predefined context.
func (target *AuditMissingValue) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Description)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Description) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Key)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Key) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AuditMissingValue type
func (target *AuditMissingValue) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AuditMissingValue type
func (target *AuditMissingValue) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AuditMissingValue. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Description = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Key = d

	return nil
}

//--------------------------------------------------------------------------
//  AuditSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AuditSet instance
// into a byte array
func (target *AuditSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AuditSet instance
// into a byte array leveraging a predefined context.
func (target *AuditSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	if target.AllocationReconciliation == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AllocationReconciliationAudit) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.AllocationReconciliation.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AllocationReconciliationAudit) ---

	}
	if target.AllocationAgg == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AggAudit) ---
		buff.WriteInt(0) // [compatibility, unused]
		errB := target.AllocationAgg.MarshalBinaryWithContext(ctx)
		if errB != nil {
			return errB
		}
		// --- [end][write][struct](AggAudit) ---

	}
	if target.AllocationTotal == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](TotalAudit) ---
		buff.WriteInt(0) // [compatibility, unused]
		errC := target.AllocationTotal.MarshalBinaryWithContext(ctx)
		if errC != nil {
			return errC
		}
		// --- [end][write][struct](TotalAudit) ---

	}
	if target.AssetTotal == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](TotalAudit) ---
		buff.WriteInt(0) // [compatibility, unused]
		errD := target.AssetTotal.MarshalBinaryWithContext(ctx)
		if errD != nil {
			return errD
		}
		// --- [end][write][struct](TotalAudit) ---

	}
	if target.AssetReconciliation == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetReconciliationAudit) ---
		buff.WriteInt(0) // [compatibility, unused]
		errE := target.AssetReconciliation.MarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		// --- [end][write][struct](AssetReconciliationAudit) ---

	}
	if target.ClusterEquality == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](EqualityAudit) ---
		buff.WriteInt(0) // [compatibility, unused]
		errF := target.ClusterEquality.MarshalBinaryWithContext(ctx)
		if errF != nil {
			return errF
		}
		// --- [end][write][struct](EqualityAudit) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errG := target.Window.MarshalBinaryWithContext(ctx)
	if errG != nil {
		return errG
	}
	// --- [end][write][struct](Window) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AuditSet type
func (target *AuditSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AuditSet type
func (target *AuditSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AuditSet. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.AllocationReconciliation = nil
	} else {
		// --- [begin][read][struct](AllocationReconciliationAudit) ---
		a := &AllocationReconciliationAudit{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.AllocationReconciliation = a
		// --- [end][read][struct](AllocationReconciliationAudit) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.AllocationAgg = nil
	} else {
		// --- [begin][read][struct](AggAudit) ---
		b := &AggAudit{}
		buff.ReadInt() // [compatibility, unused]
		errB := b.UnmarshalBinaryWithContext(ctx)
		if errB != nil {
			return errB
		}
		target.AllocationAgg = b
		// --- [end][read][struct](AggAudit) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.AllocationTotal = nil
	} else {
		// --- [begin][read][struct](TotalAudit) ---
		c := &TotalAudit{}
		buff.ReadInt() // [compatibility, unused]
		errC := c.UnmarshalBinaryWithContext(ctx)
		if errC != nil {
			return errC
		}
		target.AllocationTotal = c
		// --- [end][read][struct](TotalAudit) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.AssetTotal = nil
	} else {
		// --- [begin][read][struct](TotalAudit) ---
		d := &TotalAudit{}
		buff.ReadInt() // [compatibility, unused]
		errD := d.UnmarshalBinaryWithContext(ctx)
		if errD != nil {
			return errD
		}
		target.AssetTotal = d
		// --- [end][read][struct](TotalAudit) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.AssetReconciliation = nil
	} else {
		// --- [begin][read][struct](AssetReconciliationAudit) ---
		e := &AssetReconciliationAudit{}
		buff.ReadInt() // [compatibility, unused]
		errE := e.UnmarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		target.AssetReconciliation = e
		// --- [end][read][struct](AssetReconciliationAudit) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.ClusterEquality = nil
	} else {
		// --- [begin][read][struct](EqualityAudit) ---
		f := &EqualityAudit{}
		buff.ReadInt() // [compatibility, unused]
		errF := f.UnmarshalBinaryWithContext(ctx)
		if errF != nil {
			return errF
		}
		target.ClusterEquality = f
		// --- [end][read][struct](EqualityAudit) ---

	}
	// --- [begin][read][struct](Window) ---
	g := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errG := g.UnmarshalBinaryWithContext(ctx)
	if errG != nil {
		return errG
	}
	target.Window = *g
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  AuditSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AuditSetRange instance
// into a byte array
func (target *AuditSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this AuditSetRange instance
// into a byte array leveraging a predefined context.
func (target *AuditSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AuditSetRange type
func (target *AuditSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the AuditSetRange type
func (target *AuditSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AuditSetRange. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	return nil
}

//--------------------------------------------------------------------------
//  Breakdown
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Breakdown instance
// into a byte array
func (target *Breakdown) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Breakdown instance
// into a byte array leveraging a predefined context.
func (target *Breakdown) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	buff.WriteFloat64(target.Idle)   // write float64
	buff.WriteFloat64(target.Other)  // write float64
	buff.WriteFloat64(target.System) // write float64
	buff.WriteFloat64(target.User)   // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Breakdown type
func (target *Breakdown) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Breakdown type
func (target *Breakdown) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Breakdown. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.Idle = a

	b := buff.ReadFloat64() // read float64
	target.Other = b

	c := buff.ReadFloat64() // read float64
	target.System = c

	d := buff.ReadFloat64() // read float64
	target.User = d

	return nil
}

//--------------------------------------------------------------------------
//  Cloud
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Cloud instance
// into a byte array
func (target *Cloud) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Cloud instance
// into a byte array leveraging a predefined context.
func (target *Cloud) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.Credit)     // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Cloud type
func (target *Cloud) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Cloud type
func (target *Cloud) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Cloud. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	w := buff.ReadFloat64() // read float64
	target.Credit = w

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostAggregate
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostAggregate instance
// into a byte array
func (target *CloudCostAggregate) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostAggregate instance
// into a byte array leveraging a predefined context.
func (target *CloudCostAggregate) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostAggregateCodecVersion) // version

	// --- [begin][write][struct](CloudCostAggregateProperties) ---
	buff.WriteInt(0) // [compatibility, unused]
	errA := target.Properties.MarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	// --- [end][write][struct](CloudCostAggregateProperties) ---

	buff.WriteFloat64(target.KubernetesPercent) // write float64
	buff.WriteFloat64(target.Cost)              // write float64
	buff.WriteFloat64(target.NetCost)           // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostAggregate type
func (target *CloudCostAggregate) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostAggregate type
func (target *CloudCostAggregate) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostAggregateCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostAggregate. Expected %d or less, got %d", CloudCostAggregateCodecVersion, version)
	}

	// --- [begin][read][struct](CloudCostAggregateProperties) ---
	a := &CloudCostAggregateProperties{}
	buff.ReadInt() // [compatibility, unused]
	errA := a.UnmarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	target.Properties = *a
	// --- [end][read][struct](CloudCostAggregateProperties) ---

	b := buff.ReadFloat64() // read float64
	target.KubernetesPercent = b

	c := buff.ReadFloat64() // read float64
	target.Cost = c

	d := buff.ReadFloat64() // read float64
	target.NetCost = d

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostAggregateProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostAggregateProperties instance
// into a byte array
func (target *CloudCostAggregateProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostAggregateProperties instance
// into a byte array leveraging a predefined context.
func (target *CloudCostAggregateProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostAggregateCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Provider)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Provider) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.WorkGroupID)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.WorkGroupID) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.BillingID)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.BillingID) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.Service)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.Service) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.LabelValue)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.LabelValue) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostAggregateProperties type
func (target *CloudCostAggregateProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostAggregateProperties type
func (target *CloudCostAggregateProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostAggregateCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostAggregateProperties. Expected %d or less, got %d", CloudCostAggregateCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Provider = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.WorkGroupID = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.BillingID = g

	var m string
	if ctx.IsStringTable() {
		n := buff.ReadInt() // read string index
		m = ctx.Table[n]
	} else {
		m = buff.ReadString() // read string
	}
	l := m
	target.Service = l

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.LabelValue = o

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostAggregateSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostAggregateSet instance
// into a byte array
func (target *CloudCostAggregateSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostAggregateSet instance
// into a byte array leveraging a predefined context.
func (target *CloudCostAggregateSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostAggregateCodecVersion) // version

	if target.CloudCostAggregates == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*CloudCostAggregate) ---
		buff.WriteInt(len(target.CloudCostAggregates)) // map length
		for v, z := range target.CloudCostAggregates {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](CloudCostAggregate) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := z.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](CloudCostAggregate) ---

			}
		}
		// --- [end][write][map](map[string]*CloudCostAggregate) ---

	}
	if target.AggregationProperties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.AggregationProperties)) // array length
		for i := 0; i < len(target.AggregationProperties); i++ {
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(target.AggregationProperties[i])
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(target.AggregationProperties[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Integration)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Integration) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.LabelName)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.LabelName) // write string
	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostAggregateSet type
func (target *CloudCostAggregateSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostAggregateSet type
func (target *CloudCostAggregateSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostAggregateCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostAggregateSet. Expected %d or less, got %d", CloudCostAggregateCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.CloudCostAggregates = nil
	} else {
		// --- [begin][read][map](map[string]*CloudCostAggregate) ---
		b := buff.ReadInt() // map len
		a := make(map[string]*CloudCostAggregate, b)
		for i := 0; i < b; i++ {
			var v string
			var d string
			if ctx.IsStringTable() {
				e := buff.ReadInt() // read string index
				d = ctx.Table[e]
			} else {
				d = buff.ReadString() // read string
			}
			c := d
			v = c

			var z *CloudCostAggregate
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](CloudCostAggregate) ---
				f := &CloudCostAggregate{}
				buff.ReadInt() // [compatibility, unused]
				errA := f.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = f
				// --- [end][read][struct](CloudCostAggregate) ---

			}
			a[v] = z
		}
		target.CloudCostAggregates = a
		// --- [end][read][map](map[string]*CloudCostAggregate) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.AggregationProperties = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		h := buff.ReadInt() // array len
		g := make([]string, h)
		for j := 0; j < h; j++ {
			var k string
			var m string
			if ctx.IsStringTable() {
				n := buff.ReadInt() // read string index
				m = ctx.Table[n]
			} else {
				m = buff.ReadString() // read string
			}
			l := m
			k = l

			g[j] = k
		}
		target.AggregationProperties = g
		// --- [end][read][slice]([]string) ---

	}
	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.Integration = o

	var s string
	if ctx.IsStringTable() {
		t := buff.ReadInt() // read string index
		s = ctx.Table[t]
	} else {
		s = buff.ReadString() // read string
	}
	r := s
	target.LabelName = r

	// --- [begin][read][struct](Window) ---
	u := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := u.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *u
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostAggregateSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostAggregateSetRange instance
// into a byte array
func (target *CloudCostAggregateSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostAggregateSetRange instance
// into a byte array leveraging a predefined context.
func (target *CloudCostAggregateSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostAggregateCodecVersion) // version

	if target.CloudCostAggregateSets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*CloudCostAggregateSet) ---
		buff.WriteInt(len(target.CloudCostAggregateSets)) // array length
		for i := 0; i < len(target.CloudCostAggregateSets); i++ {
			if target.CloudCostAggregateSets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](CloudCostAggregateSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.CloudCostAggregateSets[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](CloudCostAggregateSet) ---

			}
		}
		// --- [end][write][slice]([]*CloudCostAggregateSet) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostAggregateSetRange type
func (target *CloudCostAggregateSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostAggregateSetRange type
func (target *CloudCostAggregateSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostAggregateCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostAggregateSetRange. Expected %d or less, got %d", CloudCostAggregateCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.CloudCostAggregateSets = nil
	} else {
		// --- [begin][read][slice]([]*CloudCostAggregateSet) ---
		b := buff.ReadInt() // array len
		a := make([]*CloudCostAggregateSet, b)
		for i := 0; i < b; i++ {
			var c *CloudCostAggregateSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](CloudCostAggregateSet) ---
				d := &CloudCostAggregateSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](CloudCostAggregateSet) ---

			}
			a[i] = c
		}
		target.CloudCostAggregateSets = a
		// --- [end][read][slice]([]*CloudCostAggregateSet) ---

	}
	// --- [begin][read][struct](Window) ---
	e := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := e.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *e
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostItem
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostItem instance
// into a byte array
func (target *CloudCostItem) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostItem instance
// into a byte array leveraging a predefined context.
func (target *CloudCostItem) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostItemCodecVersion) // version

	// --- [begin][write][struct](CloudCostItemProperties) ---
	buff.WriteInt(0) // [compatibility, unused]
	errA := target.Properties.MarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	// --- [end][write][struct](CloudCostItemProperties) ---

	buff.WriteBool(target.IsKubernetes) // write bool
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost)    // write float64
	buff.WriteFloat64(target.NetCost) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostItem type
func (target *CloudCostItem) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostItem type
func (target *CloudCostItem) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostItemCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostItem. Expected %d or less, got %d", CloudCostItemCodecVersion, version)
	}

	// --- [begin][read][struct](CloudCostItemProperties) ---
	a := &CloudCostItemProperties{}
	buff.ReadInt() // [compatibility, unused]
	errA := a.UnmarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	target.Properties = *a
	// --- [end][read][struct](CloudCostItemProperties) ---

	b := buff.ReadBool() // read bool
	target.IsKubernetes = b

	// --- [begin][read][struct](Window) ---
	c := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := c.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *c
	// --- [end][read][struct](Window) ---

	d := buff.ReadFloat64() // read float64
	target.Cost = d

	e := buff.ReadFloat64() // read float64
	target.NetCost = e

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostItemProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostItemProperties instance
// into a byte array
func (target *CloudCostItemProperties) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostItemProperties instance
// into a byte array leveraging a predefined context.
func (target *CloudCostItemProperties) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostItemCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.ProviderID)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.ProviderID) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Provider)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Provider) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.WorkGroupID)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.WorkGroupID) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.BillingID)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.BillingID) // write string
	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.Service)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.Service) // write string
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.Category)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.Category) // write string
	}
	// --- [begin][write][alias](CloudCostItemLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				g := ctx.Table.AddOrGet(v)
				buff.WriteInt(g) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				h := ctx.Table.AddOrGet(z)
				buff.WriteInt(h) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](CloudCostItemLabels) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostItemProperties type
func (target *CloudCostItemProperties) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostItemProperties type
func (target *CloudCostItemProperties) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostItemCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostItemProperties. Expected %d or less, got %d", CloudCostItemCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.ProviderID = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Provider = d

	var h string
	if ctx.IsStringTable() {
		k := buff.ReadInt() // read string index
		h = ctx.Table[k]
	} else {
		h = buff.ReadString() // read string
	}
	g := h
	target.WorkGroupID = g

	var m string
	if ctx.IsStringTable() {
		n := buff.ReadInt() // read string index
		m = ctx.Table[n]
	} else {
		m = buff.ReadString() // read string
	}
	l := m
	target.BillingID = l

	var p string
	if ctx.IsStringTable() {
		q := buff.ReadInt() // read string index
		p = ctx.Table[q]
	} else {
		p = buff.ReadString() // read string
	}
	o := p
	target.Service = o

	var s string
	if ctx.IsStringTable() {
		t := buff.ReadInt() // read string index
		s = ctx.Table[t]
	} else {
		s = buff.ReadString() // read string
	}
	r := s
	target.Category = r

	// --- [begin][read][alias](CloudCostItemLabels) ---
	var u map[string]string
	if buff.ReadUInt8() == uint8(0) {
		u = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		x := buff.ReadInt() // map len
		w := make(map[string]string, x)
		for i := 0; i < x; i++ {
			var v string
			var aa string
			if ctx.IsStringTable() {
				bb := buff.ReadInt() // read string index
				aa = ctx.Table[bb]
			} else {
				aa = buff.ReadString() // read string
			}
			y := aa
			v = y

			var z string
			var dd string
			if ctx.IsStringTable() {
				ee := buff.ReadInt() // read string index
				dd = ctx.Table[ee]
			} else {
				dd = buff.ReadString() // read string
			}
			cc := dd
			z = cc

			w[v] = z
		}
		u = w
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = CloudCostItemLabels(u)
	// --- [end][read][alias](CloudCostItemLabels) ---

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostItemSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostItemSet instance
// into a byte array
func (target *CloudCostItemSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostItemSet instance
// into a byte array leveraging a predefined context.
func (target *CloudCostItemSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostItemCodecVersion) // version

	if target.CloudCostItems == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*CloudCostItem) ---
		buff.WriteInt(len(target.CloudCostItems)) // map length
		for v, z := range target.CloudCostItems {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](CloudCostItem) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := z.MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](CloudCostItem) ---

			}
		}
		// --- [end][write][map](map[string]*CloudCostItem) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Integration)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Integration) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostItemSet type
func (target *CloudCostItemSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostItemSet type
func (target *CloudCostItemSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostItemCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostItemSet. Expected %d or less, got %d", CloudCostItemCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.CloudCostItems = nil
	} else {
		// --- [begin][read][map](map[string]*CloudCostItem) ---
		b := buff.ReadInt() // map len
		a := make(map[string]*CloudCostItem, b)
		for i := 0; i < b; i++ {
			var v string
			var d string
			if ctx.IsStringTable() {
				e := buff.ReadInt() // read string index
				d = ctx.Table[e]
			} else {
				d = buff.ReadString() // read string
			}
			c := d
			v = c

			var z *CloudCostItem
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](CloudCostItem) ---
				f := &CloudCostItem{}
				buff.ReadInt() // [compatibility, unused]
				errA := f.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z = f
				// --- [end][read][struct](CloudCostItem) ---

			}
			a[v] = z
		}
		target.CloudCostItems = a
		// --- [end][read][map](map[string]*CloudCostItem) ---

	}
	// --- [begin][read][struct](Window) ---
	g := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := g.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *g
	// --- [end][read][struct](Window) ---

	var k string
	if ctx.IsStringTable() {
		l := buff.ReadInt() // read string index
		k = ctx.Table[l]
	} else {
		k = buff.ReadString() // read string
	}
	h := k
	target.Integration = h

	return nil
}

//--------------------------------------------------------------------------
//  CloudCostItemSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CloudCostItemSetRange instance
// into a byte array
func (target *CloudCostItemSetRange) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CloudCostItemSetRange instance
// into a byte array leveraging a predefined context.
func (target *CloudCostItemSetRange) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(CloudCostItemCodecVersion) // version

	if target.CloudCostItemSets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*CloudCostItemSet) ---
		buff.WriteInt(len(target.CloudCostItemSets)) // array length
		for i := 0; i < len(target.CloudCostItemSets); i++ {
			if target.CloudCostItemSets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](CloudCostItemSet) ---
				buff.WriteInt(0) // [compatibility, unused]
				errA := target.CloudCostItemSets[i].MarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				// --- [end][write][struct](CloudCostItemSet) ---

			}
		}
		// --- [end][write][slice]([]*CloudCostItemSet) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CloudCostItemSetRange type
func (target *CloudCostItemSetRange) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CloudCostItemSetRange type
func (target *CloudCostItemSetRange) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > CloudCostItemCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CloudCostItemSetRange. Expected %d or less, got %d", CloudCostItemCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.CloudCostItemSets = nil
	} else {
		// --- [begin][read][slice]([]*CloudCostItemSet) ---
		b := buff.ReadInt() // array len
		a := make([]*CloudCostItemSet, b)
		for i := 0; i < b; i++ {
			var c *CloudCostItemSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](CloudCostItemSet) ---
				d := &CloudCostItemSet{}
				buff.ReadInt() // [compatibility, unused]
				errA := d.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](CloudCostItemSet) ---

			}
			a[i] = c
		}
		target.CloudCostItemSets = a
		// --- [end][read][slice]([]*CloudCostItemSet) ---

	}
	// --- [begin][read][struct](Window) ---
	e := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := e.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *e
	// --- [end][read][struct](Window) ---

	return nil
}

//--------------------------------------------------------------------------
//  ClusterManagement
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ClusterManagement instance
// into a byte array
func (target *ClusterManagement) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ClusterManagement instance
// into a byte array leveraging a predefined context.
func (target *ClusterManagement) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.Adjustment) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ClusterManagement type
func (target *ClusterManagement) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ClusterManagement type
func (target *ClusterManagement) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ClusterManagement. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	m := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := m.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *m
	// --- [end][read][struct](Window) ---

	n := buff.ReadFloat64() // read float64
	target.Cost = n

	// field version check
	if uint8(16) <= version {
		o := buff.ReadFloat64() // read float64
		target.Adjustment = o

	} else {
		target.Adjustment = float64(0) // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  Coverage
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Coverage instance
// into a byte array
func (target *Coverage) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Coverage instance
// into a byte array leveraging a predefined context.
func (target *Coverage) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errA := target.Window.MarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	// --- [end][write][struct](Window) ---

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Type)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Type) // write string
	}
	buff.WriteInt(target.Count) // write int
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.Updated.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for i := 0; i < len(target.Errors); i++ {
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(target.Errors[i])
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(target.Errors[i]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for j := 0; j < len(target.Warnings); j++ {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(target.Warnings[j])
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(target.Warnings[j]) // write string
			}
		}
		// --- [end][write][slice]([]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Coverage type
func (target *Coverage) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Coverage type
func (target *Coverage) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Coverage. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// --- [begin][read][struct](Window) ---
	a := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errA := a.UnmarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	target.Window = *a
	// --- [end][read][struct](Window) ---

	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	target.Type = b

	e := buff.ReadInt() // read int
	target.Count = e

	// --- [begin][read][reference](time.Time) ---
	f := &time.Time{}
	g := buff.ReadInt()    // byte array length
	h := buff.ReadBytes(g) // byte array
	errB := f.UnmarshalBinary(h)
	if errB != nil {
		return errB
	}
	target.Updated = *f
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		l := buff.ReadInt() // array len
		k := make([]string, l)
		for i := 0; i < l; i++ {
			var m string
			var o string
			if ctx.IsStringTable() {
				p := buff.ReadInt() // read string index
				o = ctx.Table[p]
			} else {
				o = buff.ReadString() // read string
			}
			n := o
			m = n

			k[i] = m
		}
		target.Errors = k
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		r := buff.ReadInt() // array len
		q := make([]string, r)
		for j := 0; j < r; j++ {
			var s string
			var u string
			if ctx.IsStringTable() {
				w := buff.ReadInt() // read string index
				u = ctx.Table[w]
			} else {
				u = buff.ReadString() // read string
			}
			t := u
			s = t

			q[j] = s
		}
		target.Warnings = q
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  CoverageSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this CoverageSet instance
// into a byte array
func (target *CoverageSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this CoverageSet instance
// into a byte array leveraging a predefined context.
func (target *CoverageSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errA := target.Window.MarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	// --- [end][write][struct](Window) ---

	if target.Items == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Coverage) ---
		buff.WriteInt(len(target.Items)) // map length
		for v, z := range target.Items {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Coverage) ---
				buff.WriteInt(0) // [compatibility, unused]
				errB := z.MarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				// --- [end][write][struct](Coverage) ---

			}
		}
		// --- [end][write][map](map[string]*Coverage) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the CoverageSet type
func (target *CoverageSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the CoverageSet type
func (target *CoverageSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling CoverageSet. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// --- [begin][read][struct](Window) ---
	a := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errA := a.UnmarshalBinaryWithContext(ctx)
	if errA != nil {
		return errA
	}
	target.Window = *a
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Items = nil
	} else {
		// --- [begin][read][map](map[string]*Coverage) ---
		c := buff.ReadInt() // map len
		b := make(map[string]*Coverage, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z *Coverage
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](Coverage) ---
				g := &Coverage{}
				buff.ReadInt() // [compatibility, unused]
				errB := g.UnmarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				z = g
				// --- [end][read][struct](Coverage) ---

			}
			b[v] = z
		}
		target.Items = b
		// --- [end][read][map](map[string]*Coverage) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  Disk
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Disk instance
// into a byte array
func (target *Disk) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Disk instance
// into a byte array leveraging a predefined context.
func (target *Disk) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.ByteHours)  // write float64
	buff.WriteFloat64(target.Local)      // write float64
	if target.Breakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		buff.WriteInt(0) // [compatibility, unused]
		errE := target.Breakdown.MarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		// --- [end][write][struct](Breakdown) ---

	}
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.StorageClass)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.StorageClass) // write string
	}
	if target.ByteHoursUsed == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		buff.WriteFloat64(*target.ByteHoursUsed) // write float64
	}
	if target.ByteUsageMax == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		buff.WriteFloat64(*target.ByteUsageMax) // write float64
	}
	if ctx.IsStringTable() {
		f := ctx.Table.AddOrGet(target.VolumeName)
		buff.WriteInt(f) // write table index
	} else {
		buff.WriteString(target.VolumeName) // write string
	}
	if ctx.IsStringTable() {
		g := ctx.Table.AddOrGet(target.ClaimName)
		buff.WriteInt(g) // write table index
	} else {
		buff.WriteString(target.ClaimName) // write string
	}
	if ctx.IsStringTable() {
		h := ctx.Table.AddOrGet(target.ClaimNamespace)
		buff.WriteInt(h) // write table index
	} else {
		buff.WriteString(target.ClaimNamespace) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Disk type
func (target *Disk) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Disk type
func (target *Disk) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Disk. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			var e string
			if ctx.IsStringTable() {
				f := buff.ReadInt() // read string index
				e = ctx.Table[f]
			} else {
				e = buff.ReadString() // read string
			}
			d := e
			v = d

			var z string
			var h string
			if ctx.IsStringTable() {
				k := buff.ReadInt() // read string index
				h = ctx.Table[k]
			} else {
				h = buff.ReadString() // read string
			}
			g := h
			z = g

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		l := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := l.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = l
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	w := buff.ReadFloat64() // read float64
	target.ByteHours = w

	x := buff.ReadFloat64() // read float64
	target.Local = x

	if buff.ReadUInt8() == uint8(0) {
		target.Breakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		y := &Breakdown{}
		buff.ReadInt() // [compatibility, unused]
		errE := y.UnmarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		target.Breakdown = y
		// --- [end][read][struct](Breakdown) ---

	}
	// field version check
	if uint8(17) <= version {
		var bb string
		if ctx.IsStringTable() {
			cc := buff.ReadInt() // read string index
			bb = ctx.Table[cc]
		} else {
			bb = buff.ReadString() // read string
		}
		aa := bb
		target.StorageClass = aa

	} else {
		target.StorageClass = "" // default
	}

	// field version check
	if uint8(18) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.ByteHoursUsed = nil
		} else {
			dd := buff.ReadFloat64() // read float64
			target.ByteHoursUsed = &dd

		}
	} else {
		target.ByteHoursUsed = nil

	}

	// field version check
	if uint8(18) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.ByteUsageMax = nil
		} else {
			ee := buff.ReadFloat64() // read float64
			target.ByteUsageMax = &ee

		}
	} else {
		target.ByteUsageMax = nil

	}

	// field version check
	if uint8(18) <= version {
		var gg string
		if ctx.IsStringTable() {
			hh := buff.ReadInt() // read string index
			gg = ctx.Table[hh]
		} else {
			gg = buff.ReadString() // read string
		}
		ff := gg
		target.VolumeName = ff

	} else {
		target.VolumeName = "" // default
	}

	// field version check
	if uint8(18) <= version {
		var ll string
		if ctx.IsStringTable() {
			mm := buff.ReadInt() // read string index
			ll = ctx.Table[mm]
		} else {
			ll = buff.ReadString() // read string
		}
		kk := ll
		target.ClaimName = kk

	} else {
		target.ClaimName = "" // default
	}

	// field version check
	if uint8(18) <= version {
		var oo string
		if ctx.IsStringTable() {
			pp := buff.ReadInt() // read string index
			oo = ctx.Table[pp]
		} else {
			oo = buff.ReadString() // read string
		}
		nn := oo
		target.ClaimNamespace = nn

	} else {
		target.ClaimNamespace = "" // default
	}

	return nil
}

//--------------------------------------------------------------------------
//  EqualityAudit
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this EqualityAudit instance
// into a byte array
func (target *EqualityAudit) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this EqualityAudit instance
// into a byte array leveraging a predefined context.
func (target *EqualityAudit) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	// --- [begin][write][alias](AuditStatus) ---
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(string(target.Status))
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(string(target.Status)) // write string
	}
	// --- [end][write][alias](AuditStatus) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Description)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Description) // write string
	}
	// --- [begin][write][reference](time.Time) ---
	c, errA := target.LastRun.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	if target.Clusters == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*AuditFloatResult) ---
		buff.WriteInt(len(target.Clusters)) // map length
		for v, z := range target.Clusters {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(v)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditFloatResult) ---
				buff.WriteInt(0) // [compatibility, unused]
				errB := z.MarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				// --- [end][write][struct](AuditFloatResult) ---

			}
		}
		// --- [end][write][map](map[string]*AuditFloatResult) ---

	}
	if target.MissingValues == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AuditMissingValue) ---
		buff.WriteInt(len(target.MissingValues)) // array length
		for i := 0; i < len(target.MissingValues); i++ {
			if target.MissingValues[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditMissingValue) ---
				buff.WriteInt(0) // [compatibility, unused]
				errC := target.MissingValues[i].MarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				// --- [end][write][struct](AuditMissingValue) ---

			}
		}
		// --- [end][write][slice]([]*AuditMissingValue) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the EqualityAudit type
func (target *EqualityAudit) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the EqualityAudit type
func (target *EqualityAudit) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling EqualityAudit. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	// --- [begin][read][alias](AuditStatus) ---
	var a string
	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	a = b

	target.Status = AuditStatus(a)
	// --- [end][read][alias](AuditStatus) ---

	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.Description = e

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	k := buff.ReadInt()    // byte array length
	l := buff.ReadBytes(k) // byte array
	errA := h.UnmarshalBinary(l)
	if errA != nil {
		return errA
	}
	target.LastRun = *h
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Clusters = nil
	} else {
		// --- [begin][read][map](map[string]*AuditFloatResult) ---
		n := buff.ReadInt() // map len
		m := make(map[string]*AuditFloatResult, n)
		for i := 0; i < n; i++ {
			var v string
			var p string
			if ctx.IsStringTable() {
				q := buff.ReadInt() // read string index
				p = ctx.Table[q]
			} else {
				p = buff.ReadString() // read string
			}
			o := p
			v = o

			var z *AuditFloatResult
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](AuditFloatResult) ---
				r := &AuditFloatResult{}
				buff.ReadInt() // [compatibility, unused]
				errB := r.UnmarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				z = r
				// --- [end][read][struct](AuditFloatResult) ---

			}
			m[v] = z
		}
		target.Clusters = m
		// --- [end][read][map](map[string]*AuditFloatResult) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.MissingValues = nil
	} else {
		// --- [begin][read][slice]([]*AuditMissingValue) ---
		t := buff.ReadInt() // array len
		s := make([]*AuditMissingValue, t)
		for j := 0; j < t; j++ {
			var u *AuditMissingValue
			if buff.ReadUInt8() == uint8(0) {
				u = nil
			} else {
				// --- [begin][read][struct](AuditMissingValue) ---
				w := &AuditMissingValue{}
				buff.ReadInt() // [compatibility, unused]
				errC := w.UnmarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				u = w
				// --- [end][read][struct](AuditMissingValue) ---

			}
			s[j] = u
		}
		target.MissingValues = s
		// --- [end][read][slice]([]*AuditMissingValue) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  LoadBalancer
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this LoadBalancer instance
// into a byte array
func (target *LoadBalancer) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this LoadBalancer instance
// into a byte array leveraging a predefined context.
func (target *LoadBalancer) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the LoadBalancer type
func (target *LoadBalancer) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the LoadBalancer type
func (target *LoadBalancer) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling LoadBalancer. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  Network
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Network instance
// into a byte array
func (target *Network) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Network instance
// into a byte array leveraging a predefined context.
func (target *Network) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Network type
func (target *Network) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Network type
func (target *Network) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Network. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  Node
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Node instance
// into a byte array
func (target *Node) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Node instance
// into a byte array leveraging a predefined context.
func (target *Node) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	c, errB := target.Start.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errC := target.End.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errD := target.Window.MarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Adjustment) // write float64
	if ctx.IsStringTable() {
		e := ctx.Table.AddOrGet(target.NodeType)
		buff.WriteInt(e) // write table index
	} else {
		buff.WriteString(target.NodeType) // write string
	}
	buff.WriteFloat64(target.CPUCoreHours) // write float64
	buff.WriteFloat64(target.RAMByteHours) // write float64
	buff.WriteFloat64(target.GPUHours)     // write float64
	if target.CPUBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		buff.WriteInt(0) // [compatibility, unused]
		errE := target.CPUBreakdown.MarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		// --- [end][write][struct](Breakdown) ---

	}
	if target.RAMBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		buff.WriteInt(0) // [compatibility, unused]
		errF := target.RAMBreakdown.MarshalBinaryWithContext(ctx)
		if errF != nil {
			return errF
		}
		// --- [end][write][struct](Breakdown) ---

	}
	buff.WriteFloat64(target.CPUCost)     // write float64
	buff.WriteFloat64(target.GPUCost)     // write float64
	buff.WriteFloat64(target.GPUCount)    // write float64
	buff.WriteFloat64(target.RAMCost)     // write float64
	buff.WriteFloat64(target.Discount)    // write float64
	buff.WriteFloat64(target.Preemptible) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Node type
func (target *Node) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Node type
func (target *Node) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Node. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errB := m.UnmarshalBinary(o)
	if errB != nil {
		return errB
	}
	target.Start = *m
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	p := &time.Time{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errC := p.UnmarshalBinary(r)
	if errC != nil {
		return errC
	}
	target.End = *p
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	s := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errD := s.UnmarshalBinaryWithContext(ctx)
	if errD != nil {
		return errD
	}
	target.Window = *s
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.Adjustment = t

	var w string
	if ctx.IsStringTable() {
		x := buff.ReadInt() // read string index
		w = ctx.Table[x]
	} else {
		w = buff.ReadString() // read string
	}
	u := w
	target.NodeType = u

	y := buff.ReadFloat64() // read float64
	target.CPUCoreHours = y

	aa := buff.ReadFloat64() // read float64
	target.RAMByteHours = aa

	bb := buff.ReadFloat64() // read float64
	target.GPUHours = bb

	if buff.ReadUInt8() == uint8(0) {
		target.CPUBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		cc := &Breakdown{}
		buff.ReadInt() // [compatibility, unused]
		errE := cc.UnmarshalBinaryWithContext(ctx)
		if errE != nil {
			return errE
		}
		target.CPUBreakdown = cc
		// --- [end][read][struct](Breakdown) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.RAMBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		dd := &Breakdown{}
		buff.ReadInt() // [compatibility, unused]
		errF := dd.UnmarshalBinaryWithContext(ctx)
		if errF != nil {
			return errF
		}
		target.RAMBreakdown = dd
		// --- [end][read][struct](Breakdown) ---

	}
	ee := buff.ReadFloat64() // read float64
	target.CPUCost = ee

	ff := buff.ReadFloat64() // read float64
	target.GPUCost = ff

	gg := buff.ReadFloat64() // read float64
	target.GPUCount = gg

	hh := buff.ReadFloat64() // read float64
	target.RAMCost = hh

	kk := buff.ReadFloat64() // read float64
	target.Discount = kk

	ll := buff.ReadFloat64() // read float64
	target.Preemptible = ll

	return nil
}

//--------------------------------------------------------------------------
//  PVAllocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this PVAllocation instance
// into a byte array
func (target *PVAllocation) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this PVAllocation instance
// into a byte array leveraging a predefined context.
func (target *PVAllocation) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	buff.WriteFloat64(target.ByteHours) // write float64
	buff.WriteFloat64(target.Cost)      // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the PVAllocation type
func (target *PVAllocation) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the PVAllocation type
func (target *PVAllocation) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling PVAllocation. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.ByteHours = a

	b := buff.ReadFloat64() // read float64
	target.Cost = b

	return nil
}

//--------------------------------------------------------------------------
//  PVKey
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this PVKey instance
// into a byte array
func (target *PVKey) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this PVKey instance
// into a byte array leveraging a predefined context.
func (target *PVKey) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.Cluster)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.Cluster) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the PVKey type
func (target *PVKey) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the PVKey type
func (target *PVKey) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling PVKey. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	var b string
	if ctx.IsStringTable() {
		c := buff.ReadInt() // read string index
		b = ctx.Table[c]
	} else {
		b = buff.ReadString() // read string
	}
	a := b
	target.Cluster = a

	var e string
	if ctx.IsStringTable() {
		f := buff.ReadInt() // read string index
		e = ctx.Table[f]
	} else {
		e = buff.ReadString() // read string
	}
	d := e
	target.Name = d

	return nil
}

//--------------------------------------------------------------------------
//  RawAllocationOnlyData
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this RawAllocationOnlyData instance
// into a byte array
func (target *RawAllocationOnlyData) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this RawAllocationOnlyData instance
// into a byte array leveraging a predefined context.
func (target *RawAllocationOnlyData) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AllocationCodecVersion) // version

	buff.WriteFloat64(target.CPUCoreUsageMax)  // write float64
	buff.WriteFloat64(target.RAMBytesUsageMax) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the RawAllocationOnlyData type
func (target *RawAllocationOnlyData) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the RawAllocationOnlyData type
func (target *RawAllocationOnlyData) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AllocationCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling RawAllocationOnlyData. Expected %d or less, got %d", AllocationCodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.CPUCoreUsageMax = a

	b := buff.ReadFloat64() // read float64
	target.RAMBytesUsageMax = b

	return nil
}

//--------------------------------------------------------------------------
//  SharedAsset
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this SharedAsset instance
// into a byte array
func (target *SharedAsset) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this SharedAsset instance
// into a byte array leveraging a predefined context.
func (target *SharedAsset) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AssetsCodecVersion) // version

	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Properties.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(z)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost) // write float64
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the SharedAsset type
func (target *SharedAsset) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the SharedAsset type
func (target *SharedAsset) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AssetsCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling SharedAsset. Expected %d or less, got %d", AssetsCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		buff.ReadInt() // [compatibility, unused]
		errA := a.UnmarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		target.Properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var b map[string]string
	if buff.ReadUInt8() == uint8(0) {
		b = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		d := buff.ReadInt() // map len
		c := make(map[string]string, d)
		for i := 0; i < d; i++ {
			var v string
			var f string
			if ctx.IsStringTable() {
				g := buff.ReadInt() // read string index
				f = ctx.Table[g]
			} else {
				f = buff.ReadString() // read string
			}
			e := f
			v = e

			var z string
			var k string
			if ctx.IsStringTable() {
				l := buff.ReadInt() // read string index
				k = ctx.Table[l]
			} else {
				k = buff.ReadString() // read string
			}
			h := k
			z = h

			c[v] = z
		}
		b = c
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AssetLabels(b)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][struct](Window) ---
	m := &Window{}
	buff.ReadInt() // [compatibility, unused]
	errB := m.UnmarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	target.Window = *m
	// --- [end][read][struct](Window) ---

	n := buff.ReadFloat64() // read float64
	target.Cost = n

	return nil
}

//--------------------------------------------------------------------------
//  TotalAudit
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this TotalAudit instance
// into a byte array
func (target *TotalAudit) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this TotalAudit instance
// into a byte array leveraging a predefined context.
func (target *TotalAudit) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(AuditCodecVersion) // version

	// --- [begin][write][alias](AuditStatus) ---
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(string(target.Status))
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(string(target.Status)) // write string
	}
	// --- [end][write][alias](AuditStatus) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Description)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Description) // write string
	}
	// --- [begin][write][reference](time.Time) ---
	c, errA := target.LastRun.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	if target.TotalByNode == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*AuditFloatResult) ---
		buff.WriteInt(len(target.TotalByNode)) // map length
		for v, z := range target.TotalByNode {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(v)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditFloatResult) ---
				buff.WriteInt(0) // [compatibility, unused]
				errB := z.MarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				// --- [end][write][struct](AuditFloatResult) ---

			}
		}
		// --- [end][write][map](map[string]*AuditFloatResult) ---

	}
	if target.TotalByCluster == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*AuditFloatResult) ---
		buff.WriteInt(len(target.TotalByCluster)) // map length
		for vv, zz := range target.TotalByCluster {
			if ctx.IsStringTable() {
				e := ctx.Table.AddOrGet(vv)
				buff.WriteInt(e) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			if zz == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditFloatResult) ---
				buff.WriteInt(0) // [compatibility, unused]
				errC := zz.MarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				// --- [end][write][struct](AuditFloatResult) ---

			}
		}
		// --- [end][write][map](map[string]*AuditFloatResult) ---

	}
	if target.MissingValues == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AuditMissingValue) ---
		buff.WriteInt(len(target.MissingValues)) // array length
		for i := 0; i < len(target.MissingValues); i++ {
			if target.MissingValues[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AuditMissingValue) ---
				buff.WriteInt(0) // [compatibility, unused]
				errD := target.MissingValues[i].MarshalBinaryWithContext(ctx)
				if errD != nil {
					return errD
				}
				// --- [end][write][struct](AuditMissingValue) ---

			}
		}
		// --- [end][write][slice]([]*AuditMissingValue) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the TotalAudit type
func (target *TotalAudit) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the TotalAudit type
func (target *TotalAudit) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > AuditCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling TotalAudit. Expected %d or less, got %d", AuditCodecVersion, version)
	}

	// --- [begin][read][alias](AuditStatus) ---
	var a string
	var c string
	if ctx.IsStringTable() {
		d := buff.ReadInt() // read string index
		c = ctx.Table[d]
	} else {
		c = buff.ReadString() // read string
	}
	b := c
	a = b

	target.Status = AuditStatus(a)
	// --- [end][read][alias](AuditStatus) ---

	var f string
	if ctx.IsStringTable() {
		g := buff.ReadInt() // read string index
		f = ctx.Table[g]
	} else {
		f = buff.ReadString() // read string
	}
	e := f
	target.Description = e

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	k := buff.ReadInt()    // byte array length
	l := buff.ReadBytes(k) // byte array
	errA := h.UnmarshalBinary(l)
	if errA != nil {
		return errA
	}
	target.LastRun = *h
	// --- [end][read][reference](time.Time) ---

	if buff.ReadUInt8() == uint8(0) {
		target.TotalByNode = nil
	} else {
		// --- [begin][read][map](map[string]*AuditFloatResult) ---
		n := buff.ReadInt() // map len
		m := make(map[string]*AuditFloatResult, n)
		for i := 0; i < n; i++ {
			var v string
			var p string
			if ctx.IsStringTable() {
				q := buff.ReadInt() // read string index
				p = ctx.Table[q]
			} else {
				p = buff.ReadString() // read string
			}
			o := p
			v = o

			var z *AuditFloatResult
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](AuditFloatResult) ---
				r := &AuditFloatResult{}
				buff.ReadInt() // [compatibility, unused]
				errB := r.UnmarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				z = r
				// --- [end][read][struct](AuditFloatResult) ---

			}
			m[v] = z
		}
		target.TotalByNode = m
		// --- [end][read][map](map[string]*AuditFloatResult) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.TotalByCluster = nil
	} else {
		// --- [begin][read][map](map[string]*AuditFloatResult) ---
		t := buff.ReadInt() // map len
		s := make(map[string]*AuditFloatResult, t)
		for j := 0; j < t; j++ {
			var vv string
			var w string
			if ctx.IsStringTable() {
				x := buff.ReadInt() // read string index
				w = ctx.Table[x]
			} else {
				w = buff.ReadString() // read string
			}
			u := w
			vv = u

			var zz *AuditFloatResult
			if buff.ReadUInt8() == uint8(0) {
				zz = nil
			} else {
				// --- [begin][read][struct](AuditFloatResult) ---
				y := &AuditFloatResult{}
				buff.ReadInt() // [compatibility, unused]
				errC := y.UnmarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				zz = y
				// --- [end][read][struct](AuditFloatResult) ---

			}
			s[vv] = zz
		}
		target.TotalByCluster = s
		// --- [end][read][map](map[string]*AuditFloatResult) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.MissingValues = nil
	} else {
		// --- [begin][read][slice]([]*AuditMissingValue) ---
		bb := buff.ReadInt() // array len
		aa := make([]*AuditMissingValue, bb)
		for ii := 0; ii < bb; ii++ {
			var cc *AuditMissingValue
			if buff.ReadUInt8() == uint8(0) {
				cc = nil
			} else {
				// --- [begin][read][struct](AuditMissingValue) ---
				dd := &AuditMissingValue{}
				buff.ReadInt() // [compatibility, unused]
				errD := dd.UnmarshalBinaryWithContext(ctx)
				if errD != nil {
					return errD
				}
				cc = dd
				// --- [end][read][struct](AuditMissingValue) ---

			}
			aa[ii] = cc
		}
		target.MissingValues = aa
		// --- [end][read][slice]([]*AuditMissingValue) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  Window
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Window instance
// into a byte array
func (target *Window) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Window instance
// into a byte array leveraging a predefined context.
func (target *Window) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if target.start == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		a, errA := target.start.MarshalBinary()
		if errA != nil {
			return errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][reference](time.Time) ---

	}
	if target.end == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		b, errB := target.end.MarshalBinary()
		if errB != nil {
			return errB
		}
		buff.WriteInt(len(b))
		buff.WriteBytes(b)
		// --- [end][write][reference](time.Time) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Window. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.start = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.start = a
		// --- [end][read][reference](time.Time) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.end = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		d := &time.Time{}
		e := buff.ReadInt()    // byte array length
		f := buff.ReadBytes(e) // byte array
		errB := d.UnmarshalBinary(f)
		if errB != nil {
			return errB
		}
		target.end = d
		// --- [end][read][reference](time.Time) ---

	}
	return nil
}
